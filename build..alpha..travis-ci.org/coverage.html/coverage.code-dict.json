{"/home/travis/build/npmtest/node-npmtest-jira-connector/test.js":"/* istanbul instrument in package npmtest_jira_connector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jira-connector/lib.npmtest_jira_connector.js":"/* istanbul instrument in package npmtest_jira_connector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jira_connector = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jira_connector = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jira-connector/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jira-connector && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jira_connector */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jira_connector\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jira_connector.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jira_connector.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jira_connector.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jira_connector.__dirname + '/lib.npmtest_jira_connector.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/index.js":"\"use strict\";\n\n// Core packages\nvar url = require('url');\n\n// Npm packages\nvar request = require('request');\n\n// Custom packages\nvar applicationProperties = require('./api/application-properties');\nvar attachment = require('./api/attachment');\nvar auditing = require('./api/auditing');\nvar avatar = require('./api/avatar');\nvar board = require('./api/board');\nvar comment = require('./api/comment');\nvar component = require('./api/component');\nvar customFieldOption = require('./api/customFieldOption');\nvar dashboard = require('./api/dashboard');\nvar errorStrings = require('./lib/error');\nvar field = require('./api/field');\nvar filter = require('./api/filter');\nvar group = require('./api/group');\nvar groupUserPicker = require('./api/groupUserPicker');\nvar groups = require('./api/groups');\nvar issue = require('./api/issue');\nvar issueLink = require('./api/issueLink');\nvar issueLinkType = require('./api/issueLinkType');\nvar issueType = require('./api/issueType');\nvar jql = require('./api/jql');\nvar licenseRole = require('./api/licenseRole');\nvar licenseValidator = require('./api/licenseValidator');\nvar myPermissions = require('./api/myPermissions');\nvar myPreferences = require('./api/myPreferences');\nvar myself = require('./api/myself');\nvar oauth_util = require('./lib/oauth_util');\nvar password = require('./api/password');\nvar priority = require('./api/priority');\nvar project = require('./api/project');\nvar projectCategory = require('./api/projectCategory');\nvar projectValidate = require('./api/projectValidate');\nvar reindex = require('./api/reindex');\nvar resolution = require('./api/resolution');\nvar screens = require('./api/screens');\nvar search = require('./api/search');\nvar securityLevel = require('./api/securityLevel');\nvar serverInfo = require('./api/serverInfo');\nvar settings = require('./api/settings');\nvar sprint = require('./api/sprint');\nvar status = require('./api/status');\nvar statusCategory = require('./api/statusCategory');\nvar user = require('./api/user');\nvar version = require('./api/version');\nvar webhook = require('./api/webhook');\nvar workflow = require('./api/workflow');\nvar workflowScheme = require('./api/workflowScheme');\nvar worklog = require('./api/worklog');\n\n/**\n * Represents a client for the Jira REST API\n *\n * @constructor JiraClient\n * @property {AgileBoardClient} board\n * @property {AgileSprintClient} sprint\n *\n * @property {ApplicationPropertiesClient} applicationProperties\n * @property {AttachmentClient} attachment\n * @property {AuditingClient} auditing\n * @property {AvatarClient} avatar\n * @property {CommentClient} comment\n * @property {ComponentClient} component\n * @property {CustomFieldOptionClient} customFieldOption\n * @property {DashboardClient} dashboard\n * @property {FieldClient} field\n * @property {FilterClient} filter\n * @property {GroupClient} group\n * @property {GroupUserPickerClient} groupUserPicker\n * @property {GroupsClient} groups\n * @property {IssueClient} issue\n * @property {IssueLinkClient} issueLink\n * @property {IssueLinkTypeClient} issueLinkType\n * @property {IssueTypeClient} issueType\n * @property {JqlClient} jql\n * @property {LicenseRoleClient} licenseRole\n * @property {LicenseValidatorClient} licenseValidator\n * @property {MyPermissionsClient} myPermissions\n * @property {MyPreferencesClient} myPreferences\n * @property {MyselfClient} myself\n * @property {PasswordClient} password\n * @property {PriorityClient} priority\n * @property {ProjectCategoryClient} projectCategory\n * @property {ProjectClient} project\n * @property {ProjectValidateClient} projectValidate\n * @property {ReindexClient} reindex\n * @property {ResolutionClient} resolution\n * @property {ScreensClient} screens\n * @property {SearchClient} search\n * @property {SecurityLevelClient} securityLevel\n * @property {ServerInfoClient} serverInfo\n * @property {SettingsClient} settings\n * @property {StatusCategoryClient} statusCategory\n * @property {StatusClient} status\n * @property {UserClient} user\n * @property {VersionClient} version\n * @property {WebhookClient} webhook\n * @property {WorkflowClient} workflow\n * @property {WorkflowSchemeClient} workflowScheme\n * @property {WorklogClient} worklog\n *\n * @param config The information needed to access the Jira API\n * @param {string} config.host The hostname of the Jira API.\n * @param {string} [config.protocol=https] The protocol used to accses the Jira API.\n * @param {number} [config.port=443] The port number used to connect to Jira.\n * @param {string} [config.path_prefix=\"/\"] The prefix to use in front of the path, if Jira isn't at \"/\"\n * @param {string} [config.version=2] The version of the Jira API to which you will be connecting.  Currently, only\n *     version 2 is supported.\n * @param config.auth The authentication information used tp connect to Jira. Must contain EITHER username and password\n *     OR oauth information.  Oauth information will be used over username/password authentication.\n * @param {string} [config.basic_auth.username] The username of the user that will be authenticated. MUST be included\n *     if using username and password authentication.\n * @param {string} [config.basic_auth.password] The password of the user that will be authenticated. MUST be included\n *     if using username and password authentication.\n * @param {string} [config.oauth.consumer_key] The consumer key used in the Jira Application Link for oauth\n *     authentication.  MUST be included if using OAuth.\n * @param {string} [config.oauth.private_key] The private key used for OAuth security. MUST be included if using OAuth.\n * @param {string} [config.oauth.token] The VERIFIED token used to connect to the Jira API.  MUST be included if using\n *     OAuth.\n * @param {string} [config.oauth.token_secret] The secret for the above token.  MUST be included if using Oauth.\n * @param {CookieJar} [config.cookie_jar] The CookieJar to use for every requests.\n * @param {Promise} [config.promise] Any function (constructor) compatible with Promise (bluebird, Q,...).\n *      Default - native Promise.\n */\nvar JiraClient = module.exports = function (config) {\n    if(!config.host) {\n        throw new Error(errorStrings.NO_HOST_ERROR);\n    }\n    this.host = config.host;\n    this.protocol = config.protocol ? config.protocol : 'https';\n    this.path_prefix = config.path_prefix ? config.path_prefix : '/';\n    this.port = config.port;\n    this.apiVersion = 2; // TODO Add support for other versions.\n    this.agileApiVersion = '1.0';\n    this.webhookApiVersion = '1.0';\n    this.promise = config.promise || Promise;\n\n    if (config.oauth) {\n        if (!config.oauth.consumer_key) {\n            throw new Error(errorStrings.NO_CONSUMER_KEY_ERROR);\n        } else if (!config.oauth.private_key) {\n            throw new Error(errorStrings.NO_PRIVATE_KEY_ERROR);\n        } else if (!config.oauth.token) {\n            throw new Error(errorStrings.NO_OAUTH_TOKEN_ERROR);\n        } else if (!config.oauth.token_secret) {\n            throw new Error(errorStrings.NO_OAUTH_TOKEN_SECRET_ERROR);\n        }\n\n        this.oauthConfig = config.oauth;\n        this.oauthConfig.signature_method = 'RSA-SHA1';\n\n    } else if (config.basic_auth) {\n        if (config.basic_auth.base64) {\n            this.basic_auth = {\n              base64: config.basic_auth.base64\n            }\n        } else {\n            if (!config.basic_auth.username) {\n                throw new Error(errorStrings.NO_USERNAME_ERROR);\n            } else if (!config.basic_auth.password) {\n                throw new Error(errorStrings.NO_PASSWORD_ERROR);\n            }\n\n            this.basic_auth = {\n                user: config.basic_auth.username,\n                pass: config.basic_auth.password\n            };\n        }\n    }\n\n    if (config.cookie_jar) {\n        this.cookie_jar = config.cookie_jar;\n    }\n\n    this.applicationProperties = new applicationProperties(this);\n    this.attachment = new attachment(this);\n    this.auditing = new auditing(this);\n    this.avatar = new avatar(this);\n    this.board = new board(this);\n    this.comment = new comment(this);\n    this.component = new component(this);\n    this.customFieldOption = new customFieldOption(this);\n    this.dashboard = new dashboard(this);\n    this.field = new field(this);\n    this.filter = new filter(this);\n    this.group = new group(this);\n    this.groupUserPicker = new groupUserPicker(this);\n    this.groups = new groups(this);\n    this.issue = new issue(this);\n    this.issueLink = new issueLink(this);\n    this.issueLinkType = new issueLinkType(this);\n    this.issueType = new issueType(this);\n    this.jql = new jql(this);\n    this.licenseRole = new licenseRole(this);\n    this.licenseValidator = new licenseValidator(this);\n    this.myPermissions = new myPermissions(this);\n    this.myPreferences = new myPreferences(this);\n    this.myself = new myself(this);\n    this.password = new password(this);\n    this.priority = new priority(this);\n    this.project = new project(this);\n    this.projectCategory = new projectCategory(this);\n    this.projectValidate = new projectValidate(this);\n    this.reindex = new reindex(this);\n    this.resolution = new resolution(this);\n    this.screens = new screens(this);\n    this.search = new search(this);\n    this.securityLevel = new securityLevel(this);\n    this.serverInfo = new serverInfo(this);\n    this.settings = new settings(this);\n    this.sprint = new sprint(this);\n    this.status = new status(this);\n    this.statusCategory = new statusCategory(this);\n    this.user = new user(this);\n    this.version = new version(this);\n    this.webhook = new webhook(this);\n    this.workflow = new workflow(this);\n    this.workflowScheme = new workflowScheme(this);\n    this.worklog = new worklog(this);\n};\n\n(function () {\n\n    /**\n     * Simple utility to build a REST endpoint URL for the Jira API.\n     *\n     * @method buildURL\n     * @memberOf JiraClient#\n     * @param path The path of the URL without concern for the root of the REST API.\n     * @returns {string} The constructed URL.\n     */\n    this.buildURL = function (path) {\n        var apiBasePath = this.path_prefix + 'rest/api/';\n        var version = this.apiVersion;\n        var requestUrl = url.format({\n            protocol: this.protocol,\n            hostname: this.host,\n            port: this.port,\n            pathname: apiBasePath + version + path\n        });\n\n        return decodeURIComponent(requestUrl);\n    };\n\n    /**\n     * Simple utility to build a REST endpoint URL for the Jira Agile API.\n     *\n     * @method buildAgileURL\n     * @memberOf JiraClient#\n     * @param path The path of the URL without concern for the root of the REST API.\n     * @returns {string} The constructed URL.\n     */\n    this.buildAgileURL = function (path) {\n        var apiBasePath = this.path_prefix + 'rest/agile/';\n        var version = this.agileApiVersion;\n        var requestUrl = url.format({\n            protocol: this.protocol,\n            hostname: this.host,\n            port: this.port,\n            pathname: apiBasePath + version + path\n        });\n\n        return decodeURIComponent(requestUrl);\n    };\n\n    /**\n     * Simple utility to build a REST endpoint URL for the Jira webhook API.\n     *\n     * @method buildWebhookURL\n     * @memberOf JiraClient#\n     * @param path The path of the URL without concern for the root of the REST API.\n     * @returns {string} The constructed URL.\n     */\n    this.buildWebhookURL = function (path) {\n        var apiBasePath = this.path_prefix + 'rest/webhooks/';\n        var version = this.webhookApiVersion;\n        var requestUrl = url.format({\n            protocol: this.protocol,\n            hostname: this.host,\n            port: this.port,\n            pathname: apiBasePath + version + path\n        });\n\n        return decodeURIComponent(requestUrl);\n    };\n\n    /**\n     * Make a request to the Jira API and call back with it's response.\n     *\n     * @method makeRequest\n     * @memberOf JiraClient#\n     * @param options The request options.\n     * @param [callback] Called with the APIs response.\n     * @param {string} [successString] If supplied, this is reported instead of the response body.\n     * @return {Promise} Resolved with APIs response or rejected with error\n     */\n    this.makeRequest = function (options, callback, successString) {\n        if (this.oauthConfig) {\n            options.oauth = this.oauthConfig;\n        } else if (this.basic_auth) {\n            if (this.basic_auth.base64) {\n              if (!options.headers) {\n                options.headers = {}\n              }\n              options.headers['Authorization'] = 'Basic ' + this.basic_auth.base64\n            } else {\n              options.auth = this.basic_auth;\n            }\n        }\n        if (this.cookie_jar) {\n            options.jar = this.cookie_jar;\n        }\n\n        if (callback) {\n            request(options, function (err, response, body) {\n                if (err || response.statusCode.toString()[0] != 2) {\n                    return callback(err ? err : body, null, response);\n                }\n\n            if (typeof body == 'string') {\n                try {\n                    body = JSON.parse(body);\n                } catch (jsonErr) {\n                    return callback(jsonErr, null, response);\n                }\n            }\n\n                return callback(null, successString ? successString : body, response);\n            });\n        } else if (this.promise) {\n            return new this.promise(function (resolve, reject) {\n\n                var req = request(options);\n\n                req.on('response', function(response) {\n\n                    // Saving error\n                    var error = response.statusCode.toString()[0] !== '2';\n\n                    // Collecting data\n                    var body = [];\n                    var push = body.push.bind(body);\n                    response.on('data', push);\n\n                    // Data collected\n                    response.on('end', function () {\n\n                        var result = body.join('');\n\n                        // Parsing JSON\n                        if (result[0] === '[' || result[0] === '{') {\n                            try {\n                                result = JSON.parse(result);\n                            } catch(e) {\n                                // nothing to do\n                            }\n                        }\n\n                        if (error) {\n                            response.body = result;\n                            reject(JSON.stringify(response));\n                            return;\n                        }\n\n                        resolve(result);\n                    });\n\n                });\n\n                req.on('error', reject);\n\n            });\n        }\n\n    };\n\n}).call(JiraClient.prototype);\n\nJiraClient.oauth_util = require('./lib/oauth_util');\n\nexports.oauth_util = oauth_util;\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/application-properties.js":"\"use strict\";\n\nmodule.exports = ApplicationPropertiesClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/application-properties'\n * @constructor ApplicationPropertiesClient\n * @param {JiraClient} jiraClient\n */\nfunction ApplicationPropertiesClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Gets an application property.\n     * @method getProperties\n     * @memberOf ApplicationPropertiesClient#\n     * @param [opts] The options used to make the request.\n     * @param [opts.key] A String containing the property key.\n     * @param [opts.permissionLevel] When fetching a list specifies the permission level of all items in the list.\n     * @param [opts.keyFilter] When fetching a list allows the list to be filtered by the property's start of key e.g.\n     *     \"jira.lf.*\" whould fetch only those permissions that are editable and whose keys start with \"jira.lf.\". This\n     *     is a regex\n     * @param [callback] Called when the properties are retrieved.\n     * @return {Promise} Resolved when the properties are retrieved.\n     */\n    this.getProperties = function (opts, callback) {\n        var qs = {};\n        if (opts) {\n            if (opts.key) {\n                qs.key = opts.key;\n            }\n            if (opts.keyFilter) {\n                qs.keyFilter = opts.keyFilter;\n            }\n            if (opts.permissionLevel) {\n                qs.keyFilter = opts.permissionLevel;\n            }\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/application-properties'),\n            method: 'GET',\n            followAllRedirects: true,\n            qs: qs\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify an application property via PUT. The \"value\" field present in the PUT will override thee existing value.\n     *\n     * @method getProperties\n     * @memberOf ApplicationPropertiesClient#\n     * @param opts The options for modifying the application property.\n     * @param opts.id The id of the property to be modified\n     * @param opts.property The new data for the property.  See\n     *     {@link https://docs.atlassian.com/jira/REST/latest/#d2e4891}\n     * @param [callback] Called when the property has been modified\n     * @return {Promise} Resolved when the property has been modified\n     */\n    this.setProperty = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/application-properties'),\n            method: 'GET',\n            followAllRedirects: true,\n            body: opts.property\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Property Updated');\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/attachment.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = AttachmentClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/atachment'\n *\n * @constructor AttachmentClient\n * @param {JiraClient} jiraClient\n */\nfunction AttachmentClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns the meta-data for an attachment, including the URI of the actual attached file.\n     *\n     * @method getAttachment\n     * @memberOf AttachmentClient#\n     * @param opts The options for the API request.\n     * @param opts.attachmentId The id of the attachment to retrieve\n     * @param [callback] Called when the attachment metadata is retrieved.\n     * @return {Promise} Resolved when the attachment metadata is retrieved.\n     */\n    this.getAttachment = function (opts, callback) {\n        if (!opts.attachmentId) {\n            throw new Error(errorStrings.NO_ATTACHMENT_ID_ERROR);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/attachment/' + opts.attachmentId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove an attachment from an issue.\n     *\n     * @method deleteAttachment\n     * @memberOf AttachmentClient#\n     * @param opts The options for the API request.\n     * @param opts.attachmentId The id of the attachment to delete\n     * @param [callback] Called when the attachment is deleted.\n     * @return {Promise} Resolved when the attachment is deleted.\n     */\n    this.deleteAttachment = function (opts, callback) {\n        if (!opts.attachmentId) {\n            throw new Error(errorStrings.NO_ATTACHMENT_ID_ERROR);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/attachment/' + opts.attachmentId),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Attachment Deleted');\n    };\n\n\n    /**\n     * Returns the meta informations for an attachments, specifically if they are enabled and the maximum upload size\n     * allowed.\n     *\n     * @method getGlobalAttachmentMetadata\n     * @memberOf AttachmentClient#\n     * @param opts This API request actually takes no options; this parameter is ignored.\n     * @param [callback] Called when the metadata is retrieved.\n     * @return {Promise} Resolved when the metadata is retrieved.\n     */\n    this.getGlobalAttachmentMetadata = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/attachment/meta'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/lib/error.js":"\"use strict\";\n\nexports.NO_HOST_ERROR = 'Missing \\'host\\' property.';\nexports.NO_CONSUMER_KEY_ERROR = 'Missing \\'oauth_consumer_key\\' property.';\nexports.NO_PRIVATE_KEY_ERROR = 'Missing \\'oauth_private_key\\' property.';\nexports.NO_OAUTH_TOKEN_ERROR = 'Missing \\'oauth_token\\' property.';\nexports.NO_OAUTH_TOKEN_SECRET_ERROR = 'Missing \\'oauth_token_secret\\' property.';\nexports.NO_USERNAME_ERROR = 'Missing \\'username\\' property.';\nexports.NO_PASSWORD_ERROR = 'Missing \\'password\\' property.';\nexports.NO_AUTHENTICATION_ERROR = 'Missing \\'auth\\' property.';\nexports.NO_VERIFIER_ERROR = 'Missing \\'oauth_verifier\\' property.';\nexports.INVALID_AUTHENTICATION_PROPERTY_ERROR = 'Invalid \\'auth\\' property.';\nexports.NO_ISSUE_IDENTIFIER = 'Missing Issue ID or Key';\nexports.NO_COMMENT_ID = 'Missing \\'commentID\\' property.';\nexports.NO_COMMENT_ERROR = 'Missing \\'comment\\' property.';\nexports.NO_NOTIFICATION_ERROR = 'Missing \\'notification\\' property';\nexports.NO_GLOBAL_ID_ERROR = 'Missing \\'globalId\\' property.';\nexports.NO_LINK_ID_ERROR = 'Missing \\'linkId\\' property.';\nexports.NO_TRANSITION_ERROR = 'Missing \\'transition\\' property.';\nexports.NO_ISSUE_ERROR = 'Missing \\'issue\\' property';\nexports.NO_ASSIGNEE_ERROR = 'Missing \\'assignee\\' property';\nexports.NO_WATCHER_ERROR = 'Missing \\'watcher\\' property';\nexports.NO_WORKLOG_ERROR = 'Missing \\'worklog\\' property';\nexports.NO_WORKLOG_ID_ERROR = 'Missing \\'worklogId\\' property';\nexports.NO_FILENAME_ERROR = 'Missing \\'filename\\' property';\nexports.NO_PROPERTY_KEY_ERROR = 'Missing \\'propertyKey\\' property';\nexports.NO_PROPERTY_VALUE_ERROR = 'Missing \\'propertyValue\\' property';\nexports.NO_ATTACHMENT_ID_ERROR = 'Missing \\'attachmentId\\' property';\nexports.NO_AUDIT_ERROR = 'Missing \\'audit\\' property';\nexports.NO_AVATAR_TYPE_ERROR = 'Missing \\'avatarType\\' property';\nexports.NO_COMMENT_PROPERTY_KEY_ERROR = 'Missing \\'propertyKey\\' property';\nexports.NO_COMMENT_PROPERTY_VALUE_ERROR = 'Missing \\'propertyValue\\' property';\nexports.NO_ISSUE_LINK_ERROR = 'Missing\\'issueLink\\' property';\nexports.NO_ISSUE_LINK_ID_ERROR = 'Missing\\'linkId\\' property';\nexports.NO_ISSUE_LINK_TYPE_ID = 'Missing \\'issueLinkTypeId\\' property.';\nexports.NO_FIELD_OPTION_ID_ERROR = 'Missing \\'fieldOptionId\\' property.';","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/auditing.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = AuditingClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/auditing'\n * @param {JiraClient} jiraClient\n * @constructor AuditingClient\n */\nfunction AuditingClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns auditing records filtered using provided parameters\n     *\n     * @method getAudits\n     * @memberOf AuditingClient#\n     * @param opts The filtering options for retrieving audits.\n     * @param [opts.offset] The number of record from which search starts\n     * @param [opts.limit] Maximum number of returned results (if is limit is <= 0 or > 1000, it will be set do default\n     *     value: 1000)\n     * @param [opts.filter] Text query; each record that will be returned must contain the provided text in one of its\n     *     fields\n     * @param [opts.from] Timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty\n     *     only records that where created in the same moment or after the 'from' timestamp will be provided in\n     *     response\n     * @param [opts.to] Timestamp in past; 'from' must be less or equal 'to', otherwise the result set will be empty\n     *     only records that where created in the same moment or earlier than the 'to' timestamp will be provided in\n     *     response\n     * @param [callback] Called when the audits are retrieved.\n     * @return {Promise} Resolved when the audits are retrieved.\n     */\n    this.getAudits = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/auditing/record'),\n            json: true,\n            followAllRedirects: true,\n            method: 'GET',\n            qs: {\n                offset: opts.offset,\n                limit: opts.limit,\n                filter: opts.filter,\n                from: opts.from,\n                to: opts.to\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     *\n     * @method createAudit\n     * @memberOf AuditingClient#\n     * @param opts The request options.\n     * @param opts.audit See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2557}\n     * @param [callback] Called when the audit is created.\n     * @return {Promise} Resolved when the audit is created.\n     */\n    this.createAudit = function (opts, callback) {\n        if (!opts.audit) {\n            throw new Error(errorStrings.NO_AUDIT_ERROR);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/auditing/record'),\n            json: true,\n            followAllRedirects: true,\n            method: 'POST',\n            body: opts.audit\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Audit Record Added');\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/avatar.js":"\"use strict\";\n\nvar fs = require('fs');\nvar path = require('path');\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = AvatarClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/avatar'\n * @param {JiraClient} jiraClient\n * @constructor AvatarClient\n */\nfunction AvatarClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns all system avatars of the given type.\n     *\n     * @method getAvatars\n     * @memberOf AvatarClient#\n     * @param opts The options to be used in the API request.\n     * @param opts.avatarType The avatar type.  May be 'project' or 'user'.\n     * @param [callback] Called when the avatars are retrieved.\n     * @return {Promise} Resolved when the avatars are retrieved.\n     */\n    this.getAvatars = function (opts, callback) {\n        if (!opts.avatarType) {\n            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);\n        }\n        var options = {\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/system')\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates a temporary avatar.  This function doesn't seem to work the way the Jira API describes, so for now\n     * just don't use it.\n     *\n     * @method createTemporaryAvatar\n     * @memberOf AvatarClient#\n     * @param opts The options to be used in the API request.\n     * @param opts.avatarType The avatar type.  May be 'project' or 'user'.\n     * @param opts.avatarFilename The name of the file being uploaded\n     * @param opts.avatarFileSize The size of the file\n     * @param opts.avatarFilePath The path to the avatar file.\n     * @param [callback] Called when the avatar is created.\n     * @return {Promise} Resolved when the avatar is created.\n     */\n    this.createTemporaryAvatar = function (opts, callback) {\n        if (!opts.avatarType) {\n            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);\n        }\n        var size = fs.statSync(opts.avatarFilePath).size;\n        var name = path.basename(opts.avatarFilePath);\n        var options = {\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/temporary'),\n            headers: {\n                \"X-Atlassian-Token\": \"no-check\"\n            },\n            qs: {\n                filename: name,\n                size: size\n            },\n            formData: {\n                file: fs.createReadStream(opts.avatarFilePath)\n            }\n        };\n        delete options.body;\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates the cropping instructions of the temporary avatar.  This function doesn't seem to work the way the Jira\n     * API describes, so for now just don't use it.\n     *\n     * @method cropTemporaryAvatar\n     * @memberOf AvatarClient#\n     * @param {Object} opts The options to be used in the API request.\n     * @param {string} opts.avatarType The avatar type.  May be 'project' or 'user'.\n     * @param {Object} opts.crop See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3316}\n     * @param [callback] Called when the avatar has been cropped.\n     * @return {Promise} Resolved when the avatar has been cropped.\n     */\n    this.cropTemporaryAvatar = function (opts, callback) {\n        if (!opts.avatarType) {\n            throw new Error(errorStrings.NO_AVATAR_TYPE_ERROR);\n        }\n\n        var options = {\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            uri: this.jiraClient.buildURL('/avatar/' + opts.avatarType + '/temporaryCrop'),\n            headers: {\n                \"X-Atlassian-Token\": \"no-check\"\n            },\n            body: opts.crop\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/board.js":"\"use strict\";\n\nmodule.exports = AgileBoardClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/agile/1.0/dashboard'\n * @param {JiraClient} jiraClient\n * @constructor AgileBoardClient\n */\nfunction AgileBoardClient(jiraClient) {\n  this.jiraClient = jiraClient;\n\n  /**\n   * Get a list of all dashboards, optionally filtering them.\n   *\n   * @method getAllBoards\n   * @memberOf AgileBoardClient#\n   * @param opts The request options to send to the Jira API\n   * @param [opts.type] Limits returning boards of a specific type: `scrum` or `kanban`.\n   * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of\n   *     maxResults\n   * @param [opts.maxResults] A hint as to the the maximum number of dashboards to return in each call. Note that the\n   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client\n   *     provides, dues to lack or resources or any other condition. When this happens, your results will be\n   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively\n   *     being used.\n   * @param [callback] Called when the dashboards have been retrieved.\n   * @return {Promise} Resolved when the dashboards have been retrieved.\n   */\n  this.getAllBoards = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/board'),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        type: opts.type,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n\n      return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Get a single agile board.\n   *\n   * @method getBoard\n   * @memberOf AgileBoardClient#\n   * @param opts The request options sent to the Jira API.\n   * @param opts.boardId The agile board id.\n   * @param [callback] Called when the dashboard has been retrieved\n   * @return {Promise} Resolved when the dashboard has been retrieved\n   */\n  this.getBoard = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildURL('/board/' + opts.boardId),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        filter: opts.filter,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n\n      return this.jiraClient.makeRequest(options, callback);\n  };\n\n\n  /**\n   * Get a list of all issues associated with an agile board\n   *\n   * @method getIssuesForBoard\n   * @memberOf AgileBoardClient#\n   * @param opts The request options to send to the Jira API\n   * @param opts.boardId The agile board id.\n   * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of\n   *     maxResults\n   * @param [opts.maxResults] A hint as to the the maximum number of dashboards to return in each call. Note that the\n   *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client\n   *     provides, dues to lack or resources or any other condition. When this happens, your results will be\n   *     truncated. Callers should always check the returned maxResults to determine the value that is effectively\n   *     being used.\n   * @param [callback] Called when the dashboards have been retrieved.\n   * @return {Promise} Resolved when the dashboards have been retrieved.\n   */\n  this.getIssuesForBoard = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/board/' + opts.boardId + '/issue'),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n\n      return this.jiraClient.makeRequest(options, callback);\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/comment.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = CommentClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/comment'\n * @constructor CommentClient\n * @param {JiraClient} jiraClient\n */\nfunction CommentClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns the keys of all properties for the comment identified by the key or by the id.\n     *\n     * @method getCommentPropertyKeys\n     * @memberOf CommentClient#\n     * @param opts The options passed in the request to the API.\n     * @param opts.commentId The id of the comment from which keys will be returned.\n     * @param [callback] Called when the keys have been retrieved.\n     * @return {Promise} Resolved when the keys have been retrieved.\n     */\n    this.getCommentPropertyKeys = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets the value of the specified comment's property.\n     *\n     * You can use this resource to store a custom data against the comment identified by the key or by the id. The\n     * user who stores the data is required to have permissions to administer the comment.\n     *\n     * @method setCommentProperty\n     * @memberOf CommentClient#\n     * @param opts The options passed in the request to the API.\n     * @param opts.commentId The id of the comment from which keys will be returned.\n     * @param opts.propertyKey The key of the property to be edited.\n     * @param opts.propertyValue The new value of the property.\n     * @param [callback] Called when the property has been edited.\n     * @return {Promise} Resolved when the property has been edited.\n     */\n    this.setCommentProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);\n        } else if (!opts.propertyValue) {\n            throw new Error(errorStrings.NO_COMMENT_PROPERTY_VALUE_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'PUT', opts.propertyValue);\n        return this.jiraClient.makeRequest(options, callback, 'Property Edited');\n    };\n\n    /**\n     * Returns the value of the property with a given key from the comment identified by the key or by the id. The user\n     * who retrieves the property is required to have permissions to read the comment.\n     *\n     * @method getCommentProperty\n     * @memberOf CommentClient#\n     * @param opts The options passed in the request to the API.\n     * @param opts.commentId The id of the comment from which keys will be returned.\n     * @param opts.propertyKey The key of the property to be edited.\n     * @param [callback] Called when the property has been retrieved.\n     * @return {Promise} Resolved when the property has been retrieved.\n     */\n    this.getCommentProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Removes the property from the comment identified by the key or by the id. Ths user removing the property is\n     * required to have permissions to administer the comment.\n     *\n     * @method deleteCommentProperty\n     * @memberOf CommentClient#\n     * @param opts The options passed in the request to the API.\n     * @param opts.commentId The id of the comment from which keys will be returned.\n     * @param opts.propertyKey The key of the property to be edited.\n     * @param [callback] Called when the property has been retrieved.\n     * @return {Promise} Resolved when the property has been retrieved.\n     */\n    this.deleteCommentProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_COMMENT_PROPERTY_KEY_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/' + opts.propertyKey, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Comment property deleted');\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf CommentClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {string} path The path of the endpoint following /issue/{idOrKey}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        if (!opts.commentId) {\n            throw new Error(errorStrings.NO_COMMENT_ID);\n        }\n        var basePath = '/comment/' + opts.commentId + \"/properties\";\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/component.js":"\"use strict\";\n\nmodule.exports = ComponentClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/component'\n *\n * @param {JiraClient} jiraClient\n * @constructor ComponentClient\n */\nfunction ComponentClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Create a component via POST.\n     *\n     * @method createComponent\n     * @memberOf ComponentClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.component See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3871}\n     * @param [callback] Called when the component has been created.\n     * @return {Promise} Resolved when the component has been created.\n     */\n    this.createComponent = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/component'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.component\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify a component via PUT. Any fields present in the PUT will override existing values. As a convenience, if a\n     * field is not present, it is silently ignored. If leadUserName is an empty string (\"\") the component lead will be\n     * removed.\n     *\n     * @method editComponent\n     * @memberOf ComponentClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.id The id of the component to edit.\n     * @param opts.component The new data to place in the component.  See\n     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3939}\n     * @param [callback] Called when the component has beed edited.\n     * @return {Promise} Resolved when the component has beed edited.\n     */\n    this.editComponent = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/component/' + opts.id),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.component\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a project component.\n     *\n     * @method getComponent\n     * @memberOf ComponentClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.id The id of the component to edit.\n     * @param [callback] Called when the component has been retrieved.\n     * @return {Promise} Resolved when the component has been retrieved.\n     */\n    this.getComponent = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/component/' + opts.id),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete a project component.\n     *\n     * @method deleteComponent\n     * @memberOf ComponentClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.id The id of the component to edit.\n     * @param [opts.moveIssuesTo] The new component applied to issues whose 'id' component will be deleted. If this\n     *     value is null, then the 'id' component is simply removed from the related isues.\n     * @param [callback] Called when the component has been deleted.\n     * @return {Promise} Resolved when the component has been deleted.\n     */\n    this.deleteComponent = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/component/' + opts.id),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Project Component Deleted');\n    };\n\n    /**\n     * Get counts of issues related to this component.\n     *\n     * @method getRelatedIssueCounts\n     * @memberOf ComponentClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.id The id of the component to edit.\n     * @param [callback] Called when the count has been retrieved.\n     * @return {Promise} Resolved when the count has been retrieved.\n     */\n    this.getRelatedIssueCounts = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/component/' + opts.id + '/relatedIssueCounts'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/customFieldOption.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = CustomFieldOptionClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/customFieldOptions'\n *\n * @param {JiraClient} jiraClient\n * @constructor CustomFieldOptionClient\n */\nfunction CustomFieldOptionClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a full representation of the Custom Field Option that has the given id.\n     *\n     * @method getCustomFieldOption\n     * @memberOf CustomFieldOptionClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.fieldOptionId A String containing an Custom Field Option id\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.getCustomFieldOption = function (opts, callback) {\n        if (!opts.fieldOptionId) {\n            throw new Error(errorStrings.NO_FIELD_OPTION_ID_ERROR);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/customFieldOption/' + opts.fieldOptionId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/dashboard.js":"\"use strict\";\n\nmodule.exports = DashboardClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/dashboard'\n * @param {JiraClient} jiraClient\n * @constructor DashboardClient\n */\nfunction DashboardClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Get a list of all dashboards, optionally filtering them.\n     *\n     * @method getAllDashboards\n     * @memberOf DashboardClient#\n     * @param opts The request options to send to the Jira API\n     * @param [opts.filter] An optional filter that is applied to the list of dashboards. Valid values include\n     *     \"favourite\" for returning only favourite dashboards, and \"my\" for returning dashboards that are owned by the\n     *     calling user.\n     * @param [opts.startAt] The index of the first dashboard to return (0-based). must be 0 or a multiple of\n     *     maxResults\n     * @param [opts.maxResults] A hint as to the the maximum number of dashboards to return in each call. Note that the\n     *     JIRA server reserves the right to impose a maxResults limit that is lower than the value that a client\n     *     provides, dues to lack or resources or any other condition. When this happens, your results will be\n     *     truncated. Callers should always check the returned maxResults to determine the value that is effectively\n     *     being used.\n     * @param [callback] Called when the dashboards have been retrieved.\n     * @return {Promise} Resolved when the dashboards have been retrieved.\n     */\n    this.getAllDashboards = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/dashboard'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                filter: opts.filter,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a single dashboard.\n     *\n     * @method getDashboard\n     * @memberOf DashboardClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.dashboardId The dashboard id.\n     * @param [callback] Called when the dashboard has been retrieved\n     * @return {Promise} Resolved when the dashboard has been retrieved\n     */\n    this.getDashboard = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/dashboard/' + opts.dashboardId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                filter: opts.filter,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/field.js":"\"use strict\";\n\nmodule.exports = FieldClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/field'\n *\n * @param {JiraClient} jiraClient\n * @constructor FieldClient\n */\nfunction FieldClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all fields, both System and Custom\n     *\n     * @method getAllFields\n     * @memberOf FieldClient#\n     * @param opts Ignored\n     * @param [callback] Called when the fields have been retrieved.\n     * @return {Promise} Resolved when the fields have been retrieved.\n     */\n    this.getAllFields = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/field'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates a custom field using a definition (object encapsulating custom field data)\n     *\n     * @method createCustomField\n     * @memberOf FieldClient#\n     * @param opts The request options to send to Jira\n     * @param opts.field See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3412}\n     * @param [callback] Called when the custom field has been created.\n     * @return {Promise} Resolved when the custom field has been created.\n     */\n    this.createCustomField = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/field'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.field\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/filter.js":"\"use strict\";\n\nmodule.exports = FilterClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/filter'\n *\n * @param {JiraClient} jiraClient\n * @constructor FilterClient\n */\nfunction FilterClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Creates a new filter, and returns newly created filter. Currently sets permissions just using the users default\n     * sharing permissions\n     *\n     * @method createFilter\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {Array} [opts.expand] The parameters to expand.\n     * @param {Object} opts.filter The filter to create.  See\n     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3347}\n     * @param [callback] Called when the filter has been created.\n     * @return {Promise} Resolved when the filter has been created.\n     */\n    this.createFilter = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/filter'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            qs: {},\n            body: opts.filter\n        };\n\n        if (opts.expand) {\n            options.qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                options.qs.expand += ex + ','\n            });\n        }\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a filter given an id\n     *\n     * @method getFilter\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter to retrieve\n     * @param [callback] Called when the filter has been retrieved.\n     * @return {Promise} Resolved when the filter has been retrieved.\n     */\n    this.getFilter = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates an existing filter, and returns its new value.\n     *\n     * @method updateFilter\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter to update\n     * @param {Object} opts.filter The new data for the filter.  See\n     *      {@link https://docs.atlassian.com/jira/REST/latest/#d2e3401}\n     * @param [callback] Called when the filter has been updated.\n     * @return {Promise} Resolved when the filter has been updated.\n     */\n    this.updateFilter = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'PUT', opts.filter);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete a filter.\n     *\n     * @method deleteFilter\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter to delete\n     * @param [callback] Called when the filter has been deleted.\n     * @return {Promise} Resolved when the filter has been deleted.\n     */\n    this.deleteFilter = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Filter Deleted');\n    };\n\n    /**\n     * Returns the default columns for the given filter. Currently logged in user will be used as the user making such\n     * request.\n     *\n     * @method getFilterColumns\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter for which to retrieve columns.\n     * @param [callback] Called when the columns have been retrieved.\n     * @return {Promise} Resolved when the columns have been retrieved.\n     */\n    this.getFilterColumns = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/columns', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets the default columns for the given filter\n     *\n     * @method setFilterColumns\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter for which to update columns.\n     * @param {Array} opts.columns The names of the new columns.\n     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3460}\n     * @param [callback] Called when the columns have been set\n     * @return {Promise} Resolved when the columns have been set\n     */\n    this.setFilterColumns = function (opts, callback) {\n        var body = {columns: opts.columns};\n        var options = this.buildRequestOptions(opts, '/columns', 'PUT', body);\n        return this.jiraClient.makeRequest(options, callback, 'Columns Updated');\n    };\n\n    /**\n     * Resets the columns for the given filter such that the filter no longer has its own column config.\n     *\n     * @method resetFilterColumns\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.filterId The id of the filter for which to reset columns.\n     * @param [callback] Called when the columns have been reset.\n     * @return {Promise} Resolved when the columns have been reset.\n     */\n    this.resetFilterColumns = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/columns', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Columns Reset');\n    };\n\n    /**\n     * Returns the default share scope of the logged-in user.\n     *\n     * @method getDefaultShareScore\n     * @memberOf FilterClient#\n     * @param opts Ignored.\n     * @param [callback] Called when the default share scope has been retrieved.\n     * @return {Promise} Resolved when the default share scope has been retrieved.\n     */\n    this.getDefaultShareScore = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/filter/defaultShareScope'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets the default share scope of the logged-in user.\n     *\n     * @method setDefaultShareScope\n     * @memberOf FilterClient#\n     * @param {Object} opts The request options sent to jira\n     * @param {string} opts.scope The new default share scope. Available values are GLOBAL and PRIVATE.\n     * @param [callback] Called when the default share scope has been set.\n     * @return {Promise} Resolved when the default share scope has been set.\n     */\n    this.setDefaultShareScope = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/filter/defaultShareScope'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: {\n                scope: opts.scope\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the favourite filters of the logged-in user.\n     *\n     * @method getFavouriteFilters\n     * @memberOf FilterClient#\n     * @param opts Ignored.\n     * @param [callback] Called when the list of favourites has been retrieved.\n     * @return {Promise} Resolved when the list of favourites has been retrieved.\n     */\n    this.getFavoriteFilters = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/filter/favourite'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf FilterClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {number} opts.filterId The id of the filter to use in the path.\n     * @param {Array} [opts.fields] The fields to include\n     * @param {Array} [opts.expand] The fields to expand\n     * @param {string} path The path of the endpoint following /filter/{id}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        var basePath = '/filter/' + opts.filterId;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n            qs.fields = qs.fields.slice(0, -1);\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n            qs.expand = qs.expand.slice(0, -1);\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/group.js":"\"use strict\";\n\nmodule.exports = GroupClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/group'\n *\n * These are considered experimental according to the Jira Docs, use at your own risk.\n *\n * @param {JiraClient} jiraClient\n * @constructor GroupClient\n */\nfunction GroupClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Creates a group by given group parameter Returns REST representation for the requested group.\n     *\n     * @method createGroup\n     * @memberOf GroupClient#\n     * @param opts The request options sent to jira\n     * @param opts.group The group to create.  See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2011}\n     * @param [callback] Called when the group is created\n     * @return {Promise} Resolved when the group is created\n     */\n    this.createGroup = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/group'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.group\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns REST representation for the requested group. Allows to get list of active users belonging to the\n     * specified group and its subgroups if \"users\" expand option is provided. You can page through users list by using\n     * indexes in expand param. For example to get users from index 10 to index 15 use \"users[10:15]\" expand value.\n     * This will return 6 users (if there are at least 16 users in this group). Indexes are 0-based and inclusive.\n     *\n     * @method getGroup\n     * @memberOf GroupClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.groupName A name of requested group.\n     * @param opts.expand Array of fields to expand. Currently only available expand is \"users\".\n     * @param [callback] Called when the group is retrieved.\n     * @return {Promise} Resolved when the group is retrieved.\n     */\n    this.getGroup = function (opts, callback) {\n        var qs = {\n            groupname: opts.groupName\n        };\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/group'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: qs\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Adds given user to a group. Returns the current state of the group.\n     *\n     * @method addUserToGroup\n     * @memberOf GroupClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.groupName A name of requested group.\n     * @param {string} opts.userName The name of the user to add to the group.\n     * @param [callback] Called when the user has been added to the group.\n     * @return {Promise} Resolved when the user has been added to the group.\n     */\n    this.addUserToGroup = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/group/user'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                groupname: opts.groupName\n            },\n            body: {\n                name: opts.userName\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Removes given user from a group. Returns no content\n     *\n     * @method removeUserFromGroup\n     * @memberOf GroupClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.groupName A name of requested group.\n     * @param {string} opts.userName The name of the user to add to the group.\n     * @param [callback] Called when the user has been added to the group.\n     * @return {Promise} Resolved when the user has been added to the group.\n     */\n    this.removeUserFromGroup = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/group/user'),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                groupname: opts.groupName,\n                username: opts.userName\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'User Removed from Group');\n    };\n\n    /**\n     * Deletes a group by given group parameter. Returns no content\n     *\n     * @method deleteGroup\n     * @memberOf GroupClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.groupName A group to delete.\n     * @param {string} [opts.swapGroup] A group to transfer visibility restrictions of the group that is being deleted\n     * @param [callback] Called when the group has been deleted.\n     * @return {Promise} Resolved when the group has been deleted.\n     */\n    this.deleteGroup = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/group'),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                groupname: opts.groupName,\n                swapGroup: opts.swapGroup\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Group Deleted');\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/groupUserPicker.js":"\"use strict\";\n\nmodule.exports = GroupUserPickerClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/groupuserpicker'\n * @param {JiraClient} jiraClient\n * @constructor GroupUserPickerClient\n */\nfunction GroupUserPickerClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of users and groups matching query with highlighting. This resource cannot be accessed\n     * anonymously.\n     *\n     * @method findUsersAndGroups\n     * @memberOf GroupUserPickerClient#\n     * @param {Object} opts The request options to send to the Jira API.\n     * @param {string} opts.query A string used to search username, Name or e-mail address\n     * @param {number} [opts.maxResults] the maximum number of users to return (defaults to 50). The maximum allowed\n     *     value is 1000. If you specify a value that is higher than this number, your search results will be\n     *     truncated.\n     * @param {boolean} [opts.showAvatar] Whether to show the avatar\n     * @param {string} [opts.fieldId] The custom field id, if this request comes from a custom field, such as a user\n     *     picker. Optional.\n     * @param {string} [opts.projectId] The list of project ids to further restrict the search This parameter can occur\n     *     multiple times to pass in multiple project ids. Comma separated value is not supported. This parameter is\n     *     only used when fieldId is present.\n     * @param {string} [opts.issueTypeId] The list of issue type ids to further restrict the search. This parameter can\n     *     occur multiple times to pass in multiple issue type ids. Comma separated value is not supported. Special\n     *     values such as -1 (all standard issue types), -2 (all subtask issue types) are supported. This parameter is\n     *     only used when fieldId is present.\n     * @param [callback] Called when the search is completed.\n     * @return {Promise} Resolved when the search is completed.\n     */\n    this.findUsersAndGroups = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/groupuserpicker'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                query: opts.query,\n                maxResults: opts.maxResults,\n                showAvatar: opts.showAvatar,\n                fieldId: opts.fieldId,\n                projectId: opts.projectId,\n                issueTypeId: opts.issueTypeId\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/groups.js":"\"use strict\";\n\nmodule.exports = GroupsClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/groups'\n *\n * @param {JiraClient} jiraClient\n * @constructor GroupsClient\n */\nfunction GroupsClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns groups with substrings matching a given query. This is mainly for use with the group picker, so the\n     * returned groups contain html to be used as picker suggestions. The groups are also wrapped in a single response\n     * object that also contains a header for use in the picker, specifically Showing X of Y matching groups. The\n     * number of groups returned is limited by the system property \"jira.ajax.autocomplete.limit\" The groups will be\n     * unique and sorted.\n     *\n     * @method findGroups\n     * @memberOf GroupsClient#\n     * @param {Object} opts The request options to use in the Jira API.\n     * @param {string} opts.query A string against which to match groups.  Leave this blank to return all groups.\n     * @param {string} opts.exclude A string specifying groups to exclude.\n     * @param {number} opts.maxResults The maximum number of results to return.\n     * @param [callback] Called when the groups have been retrieved.\n     * @return {Promise} Resolved when the groups have been retrieved.\n     */\n    this.findGroups = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/groups/picker'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                query: opts.query,\n                exclude: opts.exclude,\n                maxResults: opts.maxResults\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/issue.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\nvar fs = require('fs');\n\nmodule.exports = IssueClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/issue' and '/rest/agile/1.0/issue'\n * @constructor IssueClient\n * @param {JiraClient} jiraClient\n */\nfunction IssueClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns the estimation of the issue and a filedId of the field that is\n     * used for it.  The boardId parameter is required, and determines which\n     * field will be updated on an issue.\n     *\n     * @method getIssueEstimation\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this\n     *        object must contain EITHER an issueId or issueKey property;\n     *        issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of teh issue.  EX: JWR-3\n     * @param {string} [opts.boardId] The id of the board required to\n     *        determine which field is used for estimation.\n     * @param [callback] Called when the issue estimation has been retrieved.\n     * @return {Promise} Resolved when the issue estimation has been retrieved.\n     */\n    this.getIssueEstimation = function (opts, callback) {\n        var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';\n        var options = {\n            uri: this.jiraClient.buildAgileURL(endpoint),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                boardId: opts.boardId,\n                filter: opts.filter,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates the estimation of the issue.  The boardId parameter is required,\n     * and determines which field will be updated on an issue.\n     *\n     * @method setIssueEstimation\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this\n     *        object must contain EITHER an issueId or issueKey property;\n     *        issueId will be used over issueKey if both are present.\n     * @param {string} [opts.value] The value to set the issue estimation as.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of teh issue.  EX: JWR-3\n     * @param {string} [opts.boardId] The id of the board required to\n     *        determine which field is used for estimation.\n     * @param [callback] Called when the issue estimation has been created.\n     * @return {Promise} Resolved when the issue estimation has been created.\n     */\n    this.setIssueEstimation = function (opts, callback) {\n        var endpoint = '/issue/' + (opts.issueId || opts.issueKey) + '/estimation';\n        var options = {\n            uri: this.jiraClient.buildAgileURL(endpoint),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: {\n                value: opts.value,\n                filter: opts.filter,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            },\n            qs: {\n              boardId: opts.boardId\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Moves (ranks) issues before or after a given issue.\n     *\n     * @method setIssueRanks\n     * @memberOf IssueClient#\n     * @param {Object} ranking The ranking data in the form of PUT body to the\n     *        Jira API.\n     * @param [callback] Called when the issue rank has been created.\n     * @return {Promise} Resolved when the issue rank has been created.\n     */\n    this.setIssueRanks = function (ranking, callback) {\n        var options = {\n            uri: this.jiraClient.buildAgileURL('/issue/rank'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: ranking\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates an issue or a sub-task from a JSON representation.\n     *\n     * The fields that can be set on create, in either the fields parameter or the update parameter can be determined\n     * using the /rest/api/2/issue/createmeta resource. If a field is not configured to appear on the create screen,\n     * then it will not be in the createmeta, and a field validation error will occur if it is submitted.\n     *\n     * Creating a sub-task is similar to creating a regular issue, with two important differences:\n     *\n     * * the issueType field must correspond to a sub-task issue type (you can use /issue/createmeta to discover\n     * sub-task issue types), and\n     * * you must provide a parent field in the issue create request containing the id or key of the parent issue.\n     *\n     * @method createIssue\n     * @memberof IssueClient#\n     * @param {Object} issue The issue data in the form of POST body to the JIRA API.\n     * See {@link https://docs.atlassian.com/jira/REST/latest/#d2e398}\n     * @param [callback] Called when the issue has been created.\n     * @return {Promise} Resolved when the issue has been created.\n     */\n    this.createIssue = function (issue, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issue'),\n            method: 'POST',\n            followAllRedirects: true,\n            json: true,\n            body: issue\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the meta data for creating issues. This includes the available projects, issue types and fields,\n     * including field types and whether or not those fields are required. Projects will not be returned if the user\n     * does not have permission to create issues in that project.\n     *\n     * The fields in the createmeta correspond to the fields in the create screen for the project/issuetype. Fields not\n     * in the screen will not be in the createmeta.\n     *\n     * Fields will only be returned if ```expand=projects.issuetypes.fields.```\n     *\n     * The results can be filtered by project and/or issue type, given by the query params.\n     *\n     * @method getCreateMetadata\n     * @memberOf IssueClient#\n     * @param {Object} [opts] The options for the API request.\n     * @param {string} [opts.projectIds] combined with the projectKeys param, lists the projects with which to filter\n     *     the results. If absent, all projects are returned. This parameter can be specified multiple times, and/or be\n     *     a comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is\n     *     not an error, but it will not be in the results.\n     * @param {string} [opts.projectKeys] combined with the projectIds param, lists the projects with which to filter\n     *     the results. If null, all projects are returned. This parameter can be specified multiple times, and/or be a\n     *     comma-separated list. Specifiying a project that does not exist (or that you cannot create issues in) is not\n     *     an error, but it will not be in the results.\n     * @param {string} [opts.issuetypeIds] combinded with issuetypeNames, lists the issue types with which to filter\n     *     the results. If null, all issue types are returned. This parameter can be specified multiple times, and/or\n     *     be a comma-separated list. Specifiying an issue type that does not exist is not an error.\n     * @param {string} [opts.issuetypeNames] combinded with issuetypeIds, lists the issue types with which to filter\n     *     the results. If null, all issue types are returned. This parameter can be specified multiple times, but is\n     *     NOT interpreted as a comma-separated list. Specifiying an issue type that does not exist is not an error.\n     * @param {string} [opts.expand] in order to get expanded field descriptions, specify 'projects.issuetypes.fields' here.\n     * @param [callback] Called when the metadata has been retrieved.\n     * @return {Promise} Resolved when the metadata has been retrieved.\n     */\n    this.getCreateMetadata = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issue/createmeta'),\n            method: 'GET',\n            followAllRedirects: true,\n            json: true,\n            qs: {\n                projectIds: opts.projectIds,\n                projectKeys: opts.projectKeys,\n                issuetypeIds: opts.issuetypeIds,\n                issuetypeNames: opts.issuetypeNames,\n                expand: opts.expand\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates issues or sub-tasks from a JSON representation.\n     *\n     * Creates many issues in one bulk operation.\n     *\n     * Creating a sub-task is similar to creating a regular issue. More details can be found in createIssue section:\n     * {@link IssueResource#createIssue(IssueUpdateBean)}}\n     *\n     * @method bulkCreate\n     * @memberof IssueClient#\n     * @param issues See {@link https://docs.atlassian.com/jira/REST/latest/#d2e828}\n     * @param [callback] Called when the issues have been created.\n     * @return {Promise} Resolved when the issues have been created.\n     */\n    this.bulkCreate = function (issues, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issue/bulk'),\n            method: 'POST',\n            followAllRedirects: true,\n            json: true,\n            body: issues\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a full representation of the issue for the given issue key.\n     *\n     * An issue JSON consists of the issue key, a collection of fields, a link to the workflow transition sub-resource,\n     * and (optionally) the HTML rendered values of any fields that support it (e.g. if wiki syntax is enabled for the\n     * description or comments).\n     *\n     * The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in\n     * the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing\n     * it with a minus.\n     *\n     * By default, all (\\*all) fields are returned in this get-issue resource. Note: the default is different when doing\n     * a jql search -- the default there is just navigable fields (\\*navigable).\n     *\n     * * \\*all - include all fields\n     * * \\*navigable - include just navigable fields\n     * * summary,comment - include just the summary and comments\n     * * -comment - include everything except comments (the default is *all for get-issue)\n     * * \\*all,-comment - include everything except comments\n     *\n     * JIRA will attempt to identify the issue by the issueIdOrKey path parameter. This can be an issue id, or an issue\n     * key. If the issue cannot be found via an exact match, JIRA will also look for the issue in a case-insensitive\n     * way, or by looking to see if the issue was moved. In either of these cases, the request will proceed as normal\n     * (a 302 or other redirect will not be returned). The issue key contained in the response will indicate the\n     * current value of issue's key.\n     *\n     * @method getIssue\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {boolean} [opts.agile] Whether or not to call the agile version of this endpoint.  Defaults to false.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} [opts.fields] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\n     * @param {Object} [opts.expand] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\n     * @param {Object} [opts.properties] See {@link https://docs.atlassian.com/jira/REST/latest/#d2e611}\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.getIssue = function (opts, callback) {\n        if (!opts.agile) {\n            var options = this.buildRequestOptions(opts, '', 'GET');\n        } else {\n            var endpoint = '/issue/' + (opts.issueId || opts.issueKey);\n            var options = {\n                uri: this.jiraClient.buildAgileURL(endpoint),\n                method: 'GET',\n                json: true,\n                followAllRedirects: true,\n                qs: {\n                    filter: opts.filter,\n                    startAt: opts.startAt,\n                    maxResults: opts.maxResults,\n                    expand: opts.expand\n                }\n            };\n        }\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete an issue. If the issue has subtasks you must set the parameter deleteSubtasks=true to delete the issue.\n     * You cannot delete an issue without its subtasks also being deleted.\n     *\n     * @method deleteIssue\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {boolean} [opts.deleteSubTasks] \"a String of true or false indicating that any subtasks should also\n     *        be deleted. If the issue has no subtasks this parameter is ignored. If the issue has subtasks and this\n     *        parameter is missing or false, then the issue will not be deleted and an error will be returned.\"\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.deleteIssue = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'DELETE', null, {deleteSubTasks: opts.deleteSubTasks});\n\n        return this.jiraClient.makeRequest(options, callback, 'Issue Deleted');\n    };\n\n    /**\n     *  Edits an issue from a JSON representation.\n     *\n     * The issue can either be updated by setting explicit the field value(s) or by using an operation to change the\n     * field value.\n     *\n     * The fields that can be updated, in either the fields parameter or the update parameter, can be determined using\n     * the {@link IssueClient#getEditMetadata} method. If a field is not configured to appear on the edit\n     * screen, then it will not be in the editmeta, and a field validation error will occur if it is submitted.\n     *\n     * Specifying a \"field_id\": field_value in the \"fields\" is a shorthand for a \"set\" operation in the \"update\"\n     * section. Field should appear either in \"fields\" or \"update\", not in both.\n     *\n     * @method editIssue\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.issue See {@link https://docs.atlassian.com/jira/REST/latest/#d2e656}\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.editIssue = function (opts, callback) {\n        if (!opts.issue) {\n            throw new Error(errorStrings.NO_ISSUE_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '', 'PUT', opts.issue, opts.qs);\n\n        return this.jiraClient.makeRequest(options, callback, 'Issue Updated');\n    };\n\n    /**\n     * Assigns an issue to a user. You can use this resource to assign issues when the user submitting the request has\n     * the assign permission but not the edit issue permission. If the name is \"-1\" automatic assignee is used. A null\n     * name will remove the assignee.\n     *\n     * @method assignIssue\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.assignee The name of the user to whom to assign the issue. -1 for default, null for no\n     *     assignee.\n     * @param [callback] Called when the issue has been assigned.\n     * @return {Promise} Resolved when the issue has been assigned.\n     */\n    this.assignIssue = function (opts, callback) {\n        if (!(typeof opts.assignee === \"string\" && opts.assignee.length || opts.assignee === null)) {\n            throw new Error(errorStrings.NO_ASSIGNEE_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/assignee', 'PUT', {name: opts.assignee});\n\n        return this.jiraClient.makeRequest(options, callback, 'Issue Assigned');\n    };\n\n    /**\n     * Get all the comments for an issue.\n     *\n     * @method getComments\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.expand See {@link https://docs.atlassian.com/jira/REST/latest/#d2e461}\n     * @param [callback] Called when the issue has been assigned.\n     * @return {Promise} Resolved when the issue has been assigned.\n     */\n    this.getComments = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/comment', 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Add a comment to an issue\n     *\n     * @method addComment\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.comment See {@link https://docs.atlassian.com/jira/REST/latest/#d2e482}\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.addComment = function (opts, callback) {\n        var options;\n        if(opts.comment.body) {\n            options = this.buildRequestOptions(opts, '/comment', 'POST', opts.comment);\n        } else {\n            options = this.buildRequestOptions(opts, '/comment', 'POST', {body: opts.comment});\n        }\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a specific comment.\n     *\n     * @method getComment\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.commentId The id of the comment.\n     * @param [callback] Called when the comment is retrieved.\n     * @return {Promise} Resolved when the comment is retrieved.\n     */\n    this.getComment = function (opts, callback) {\n        if (!opts.commentId) {\n            throw new Error(errorStrings.NO_COMMENT_ID);\n        }\n        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates an existing comment using its JSON representation.\n     *\n     * @method editComment\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.commentId The id of the comment.\n     * @param {Object} opts.comment See {@link https://docs.atlassian.com/jira/REST/latest/#d2e539}\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.editComment = function (opts, callback) {\n        if (!opts.comment) {\n            throw new Error(errorStrings.NO_COMMENT_ERROR);\n        } else if (!opts.commentId) {\n            throw new Error(errorStrings.NO_COMMENT_ID);\n        }\n        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'PUT', opts.comment);\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete an existing comment.\n     *\n     * @method deleteComment\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.commentId The id of the comment.\n     * @param [callback] Called when the comment is retrieved.\n     * @return {Promise} Resolved when the comment is retrieved.\n     */\n    this.deleteComment = function (opts, callback) {\n        if (!opts.commentId) {\n            throw new Error(errorStrings.NO_COMMENT_ID);\n        }\n        var options = this.buildRequestOptions(opts, '/comment/' + opts.commentId, 'DELETE');\n\n        return this.jiraClient.makeRequest(options, callback, 'Comment Deleted');\n    };\n\n    /**\n     * Returns the meta data for editing an issue.\n     *\n     * The fields in the editmeta correspond to the fields in the edit screen for the issue. Fields not in the screen\n     * will not be in the editemeta.\n     *\n     * @method getEditMetadata\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called when the metadata is retrieved.\n     * @return {Promise} Resolved when the metadata is retrieved.\n     */\n    this.getEditMetadata = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/editmeta', 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sends a notification (email) to the list or recipients defined in the request.\n     * A couple of notes: this may call back with the error 'No recipients were defined for notification.' if all\n     * of the intended recipients have disabled notifications from Jira.\n     *\n     * @method sendEmailNotification\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *        issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.notification See {@link https://docs.atlassian.com/jira/REST/latest/#d2e435}\n     * @param [callback] Called when the metadata is retrieved.\n     * @return {Promise} Resolved when the metadata is retrieved.\n     */\n    this.sendEmailNotification = function (opts, callback) {\n        if (!opts.notification) {\n            throw new Error(errorStrings.NO_NOTIFICATION_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/notify', 'POST', opts.notification);\n\n        return this.jiraClient.makeRequest(options, callback, 'Notifications Sent');\n    };\n\n    /**\n     * Get a REST sub-resource representing the remote issue links on the issue.\n     *\n     * @method getRemoteLinks\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.globalId The id of the remote issue link to be returned. If null (not provided) all remote\n     *     links for the issue are returned. For a full explanation of Issue Link fields please refer to\n     *     {@link https://developer.atlassian.com/display/JIRADEV/Fields+in+Remote+Issue+Links}\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.getRemoteLinks = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink', 'GET', null, {globalId: opts.globalId});\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates (or updates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue\n     * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.\n     *\n     * @method createRemoteLink\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.createRemoteLink = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink', 'POST', opts.remoteLink);\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates (or creates) a remote issue link from a JSON representation. If a globalId is provided and a remote issue\n     * link exists with that globalId, the remote issue link is updated. Otherwise, the remote issue link is created.\n     *\n     * @method updateRemoteLink\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {Object} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e945}\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.updateRemoteLink = function (opts, callback) {\n        // The one API endpoint handles both updates and creation.\n        this.createRemoteLink(opts, callback);\n    };\n\n    /**\n     * Delete the remote issue link with the given global id on the issue.\n     *\n     * @method deleteRemoteLink\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.globalId The global id of the remote issue link\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.deleteRemoteLink = function (opts, callback) {\n        if (!opts.globalId) {\n            throw new Error(errorStrings.NO_GLOBAL_ID_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/remotelink', 'DELETE', null, {globalId: opts.globalId});\n\n        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');\n    };\n\n    /**\n     * Get the remote issue link with the given id on the issue.\n     *\n     * @method getRemoteLinkById\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.linkId The id of the remote link\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.getRemoteLinkById = function (opts, callback) {\n        if (!opts.linkId) {\n            throw new Error(errorStrings.NO_LINK_ID_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the remote issue link with the given id on the issue.\n     *\n     * @method updateRemoteLinkById\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.linkId The id of the remote link\n     * @param {string} opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e1037}\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.updateRemoteLinkById = function (opts, callback) {\n        if (!opts.linkId) {\n            throw new Error(errorStrings.NO_LINK_ID_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'PUT', opts.remoteLink);\n\n        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Updated');\n    };\n\n    /**\n     * Get the remote issue link with the given id on the issue.\n     *\n     * @method deleteRemoteLinkById\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.linkId The id of the remote link\n     * @param [callback] Called when the remote links are retrieved.\n     * @return {Promise} Resolved when the remote links are retrieved.\n     */\n    this.deleteRemoteLinkById = function (opts, callback) {\n        if (!opts.linkId) {\n            throw new Error(errorStrings.NO_LINK_ID_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.linkId, 'DELETE');\n\n        return this.jiraClient.makeRequest(options, callback, 'RemoteLink Deleted');\n    };\n\n    /**\n     * Get a list of the transitions possible for this issue by the current user, along with fields that are required\n     * and their types.\n     *\n     * Fields will only be returned if ```expand=transitions.fields.```\n     *\n     * The fields in the metadata correspond to the fields in the transition screen for that transition. Fields not in\n     * the screen will not be in the metadata.\n     *\n     * @method getTransitions\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.transitionId If specified, will call back with only the transition with the specified id.\n     * @param [callback] Called when the transitions are retrieved.\n     * @return {Promise} Resolved when the transitions are retrieved.\n     */\n    this.getTransitions = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/transitions', 'GET', null, {transitionId: opts.transitionId});\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Perform a transition on an issue. When performing the transition you can udate or set other issue fields.\n     *\n     * The fields that can be set on transtion, in either the fields parameter or the update parameter can be\n     * determined using the** /rest/api/2/issue/{issueIdOrKey}/transitions?expand=transitions.fields resource**. If a\n     * field is not configured to appear on the transition screen, then it will not be in the transition metadata, and\n     * a field validation error will occur if it is submitted.\n     *\n     * @method transitionIssue\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.transition See {@link https://docs.atlassian.com/jira/REST/latest/#d2e698}\n     * @param [callback] Called when the transitions are retrieved.\n     * @return {Promise} Resolved when the transitions are retrieved.\n     */\n    this.transitionIssue = function (opts, callback) {\n        if (!opts.transition) {\n            throw new Error(errorStrings.NO_TRANSITION_ERROR);\n        }\n\n        var options;\n        if(!opts.transition.transition) { // To keep backwards compatibility\n            options = this.buildRequestOptions(opts, '/transitions', 'POST', opts);\n        } else {\n            options = this.buildRequestOptions(opts, '/transitions', 'POST', opts.transition)\n        }\n        return this.jiraClient.makeRequest(options, callback, 'Issue Transitioned');\n    };\n\n    /**\n     * Remove your vote from an issue. (i.e. \"unvote\")\n     *\n     * @method unvote\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called after the vote is removed.\n     * @return {Promise} Resolved after the vote is removed.\n     */\n    this.unvote = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/votes', 'DELETE');\n\n        return this.jiraClient.makeRequest(options, callback, 'Vote Removed');\n    };\n\n    /**\n     * Cast your vote in favour of an issue.\n     *\n     * @method vote\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called after the vote is removed.\n     * @return {Promise} Resolved after the vote is removed.\n     */\n    this.vote = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/votes', 'POST');\n\n        return this.jiraClient.makeRequest(options, callback, 'Vote Added');\n    };\n\n    /**\n     * Get a REST sub-resource representing the voters on the issue.\n     *\n     * @method getVotes\n     * @memberof IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called after the votes are retrieved.\n     * @return {Promise} Resolved after the votes are retrieved.\n     */\n    this.getVotes = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/votes', 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the list of watchers for the issue with the given key.\n     *\n     * @method getWatchers\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called after the watchers are retrieved.\n     * @return {Promise} Resolved after the watchers are retrieved.\n     */\n    this.getWatchers = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/watchers', 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Adds a user to an issue's watcher list.\n     *\n     * @method addWatcher\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.watcher The username of the user to add as a watcher.\n     * @param [callback] Called after the watcher is added.\n     * @return {Promise} Resolved after the watcher is added.\n     */\n    this.addWatcher = function (opts, callback) {\n        if (!opts.watcher) {\n            throw new Error(errorStrings.NO_WATCHER_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/watchers', 'POST', opts.watcher);\n\n        return this.jiraClient.makeRequest(options, callback, 'Watcher Added');\n    };\n\n    /**\n     * Adds a user to an issue's watcher list.\n     *\n     * @method removeWatcher\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.watcher The username of the user to remove as a watcher.\n     * @param [callback] Called after the watcher is removed.\n     * @return {Promise} Resolved after the watcher is removed.\n     */\n    this.removeWatcher = function (opts, callback) {\n        if (!opts.watcher) {\n            throw new Error(errorStrings.NO_WATCHER_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/watchers', 'DELETE', null, {username: opts.watcher});\n\n        return this.jiraClient.makeRequest(options, callback, 'Watcher Removed');\n    };\n\n    /**\n     * Gets all work logs for an issue.\n     *\n     * @method getWorkLogs\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called after the worklogs are retrieved.\n     * @return {Promise} Resolved after the worklogs are retrieved.\n     */\n    this.getWorkLogs = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/worklog', 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Adds a new worklog entry to an issue.\n     *\n     * @method addWorkLog\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\n     *     estimate of the issue. Valid values are\n     *     * \"new\" - sets the estimate to a specific value\n     *     * \"leave\"- leaves the estimate as is\n     *     * \"manual\" - specify a specific amount to increase remaining estimate by\n     *     * \"auto\"- Default option. Will automatically adjust the value based on the\n     *          new timeSpent specified on the worklog\n     * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\n     *     remaining estimate field. e.g. \"2d\"\n     * @param {string} [opts.reduceBy] (required when \"manual\" is selected for adjustEstimate) the amount to reduce the\n     *     remaining estimate by e.g. \"2d\"\n     * @param {Object} opts.worklog See {@link: https://docs.atlassian.com/jira/REST/latest/#d2e1106}\n     * @param [callback] Called after the worklog is added.\n     * @return {Promise} Resolved after the worklog is added.\n     */\n    this.addWorkLog = function (opts, callback) {\n        if (!opts.worklog) {\n            throw new Error(errorStrings.NO_WORKLOG_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/worklog', 'POST', opts.worklog, {\n            newEstimate: opts.newEstimate,\n            reduceBy: opts.reduceBy,\n            adjustEstimate: opts.adjustEstimate\n        });\n\n        return this.jiraClient.makeRequest(options, callback, 'Worklog Added');\n    };\n\n    /**\n     * Gets a specific worklog.\n     *\n     * @method getWorkLog\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.worklogId The id of the work log to retrieve.\n     * @param [callback] Called after the worklog is retrieved.\n     * @return {Promise} Resolved after the worklog is retrieved.\n     */\n    this.getWorkLog = function (opts, callback) {\n        if (!opts.worklogId) {\n            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'GET');\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates an existing worklog entry using its JSON representation.\n     *\n     * @method updateWorkLog\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.worklogId The id of the work log to retrieve.\n     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\n     *     estimate of the issue. Valid values are\n     *     * \"new\" - sets the estimate to a specific value\n     *     * \"leave\"- leaves the estimate as is\n     *     * \"auto\"- Default option. Will automatically adjust the value based on the\n     *          new timeSpent specified on the worklog\n     * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\n     *     remaining estimate field. e.g. \"2d\"\n     * @param {Object} opts.worklog See {@link: https://docs.atlassian.com/jira/REST/latest/#d2e1161}\n     * @param [callback] Called after the worklog is updated.\n     * @return {Promise} Resolved after the worklog is updated.\n     */\n    this.updateWorkLog = function (opts, callback) {\n        if (!opts.worklogId) {\n            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);\n        } else if (!opts.worklog) {\n            throw new Error(errorStrings.NO_WORKLOG_ERROR);\n        }\n\n        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'PUT', opts.worklog, {\n            newEstimate: opts.newEstimate,\n            adjustEstimate: opts.adjustEstimate\n        });\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Deletes an existing worklog entry\n     *\n     * @method deleteWorkLog\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.worklogId The id of the work log to delete.\n     * @param {string} [opts.adjustEstimate] Allows you to provide specific instructions to update the remaining time\n     *     estimate of the issue. Valid values are\n     *     * \"new\" - sets the estimate to a specific value\n     *     * \"leave\"- leaves the estimate as is\n     *     * \"manual\" - specify a specific amount to increase remaining estimate by\n     *     * \"auto\"- Default option. Will automatically adjust the value based on the\n     *          new timeSpent specified on the worklog\n     * @param {string} [opts.newEstimate] (required when \"new\" is selected for adjustEstimate) the new value for the\n     *     remaining estimate field. e.g. \"2d\"\n     * @param {string} [opts.increaseBy] (required when \"manual\" is selected for adjustEstimate) the amount to reduce\n     *     the remaining estimate by e.g. \"2d\"\n     * @param [callback] Called after the work log is deleted.\n     * @return {Promise} Resolved after the work log is deleted.\n     */\n    this.deleteWorkLog = function (opts, callback) {\n        if (!opts.worklogId) {\n            throw new Error(errorStrings.NO_WORKLOG_ID_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/worklog/' + opts.worklogId, 'DELETE', null, {\n            newEstimate: opts.newEstimate,\n            increaseBy: opts.increaseBy,\n            adjustEstimate: opts.adjustEstimate\n        });\n        return this.jiraClient.makeRequest(options, callback, 'Work Log Deleted');\n    };\n\n    /**\n     * Add an attachments to an issue.\n     *\n     * @method addAttachment\n     * @memberOf IssueClient\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.filename The file name of attachment. If you pass an array of filenames, multiple attachments will be added.\n     * @param [callback] Called when the attachment has been attached.\n     * @return {Promise} Resolved when the attachment has been attached.\n     */\n    this.addAttachment = function (opts, callback) {\n        if (!opts.filename) {\n            throw new Error(errorStrings.NO_FILENAME_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/attachments', 'POST');\n        delete options.body;\n        if (opts.filename.constructor !== Array) opts.filename = [opts.filename];\n        var attachments = opts.filename.map (function (filename) {return fs.createReadStream(filename)});\n        options.formData = {file: attachments};\n        options.headers = {\n            \"X-Atlassian-Token\": \"nocheck\"\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the keys of all properties for the issue identified by the key or by the id.  This function is maked as\n     * experimental in the Jira API docs, use at your own risk.\n     *\n     * @method getProperties\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param [callback] Called when the properties are retrieved.\n     * @return {Promise} Resolved when the properties are retrieved.\n     */\n    this.getProperties = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/properties', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets the value of the specified issue's property. You can use this resource to store a custom data against the\n     * issue identified by the key or by the id. The user who stores the data is required to have permissions to edit\n     * the issue.\n     *\n     * This function is maked as experimental in the Jira API docs, use at your own risk.\n     *\n     * @method setProperty\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.propertyKey The key of the property being set.\n     * @param {Object} opts.propertyValue The value of the property being set.\n     * @param [callback] Called when the property is set.\n     * @return {Promise} Resolved when the property is set.\n     */\n    this.setProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n        } else if (!opts.propertyValue) {\n            throw new Error(errorStrings.NO_PROPERTY_VALUE_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'PUT', opts.propertyValue);\n        return this.jiraClient.makeRequest(options, callback, 'Property Set');\n    };\n\n    /**\n     * Returns the value of the property with a given key from the issue identified by the key or by the id. The user\n     * who retrieves the property is required to have permissions to read the issue.\n     *\n     * This function is maked as experimental in the Jira API docs, use at your own risk.\n     *\n     * @method getProperty\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.propertyKey The key of the property being set.\n     * @param [callback] Called when the property is retrieved.\n     * @return {Promise} Resolved when the property is retrieved.\n     */\n    this.getProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Removes the property from the issue identified by the key or by the id. Ths user removing the property is\n     * required to have permissions to edit the issue.\n     *\n     * This function is maked as experimental in the Jira API docs, use at your own risk.\n     *\n     * @method getProperty\n     * @memberOf IssueClient#\n     * @param {Object} opts The options to pass to the API.  Note that this object must contain EITHER an issueId or\n     *     issueKey property; issueId will be used over issueKey if both are present.\n     * @param {string} [opts.issueId] The id of the issue.  EX: 10002\n     * @param {string} [opts.issueKey] The Key of the issue.  EX: JWR-3\n     * @param {string} opts.propertyKey The key of the property being set.\n     * @param [callback] Called when the property is deleted.\n     * @return {Promise} Resolved when the property is deleted.\n     */\n    this.deleteProperty = function (opts, callback) {\n        if (!opts.propertyKey) {\n            throw new Error(errorStrings.NO_PROPERTY_KEY_ERROR);\n        }\n        var options = this.buildRequestOptions(opts, '/properties/' + opts.propertyKey, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Property Deleted');\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @param {Object} opts The arguments passed to the method.\n     * @param {string} path The path of the endpoint following /issue/{idOrKey}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        if (!opts.issueId && !opts.issueKey) {\n            throw new Error(errorStrings.NO_ISSUE_IDENTIFIER);\n        }\n        var idOrKey = opts.issueId || opts.issueKey;\n        var basePath = '/issue/' + idOrKey;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n        }\n\n        if (opts.properties) {\n            qs.properties = '';\n            opts.properties.forEach(function (prop) {\n                qs.properties += prop + ','\n            });\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    }\n\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/issueLink.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = IssueLinkClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/issueLink'\n * @param {JiraClient} jiraClient\n * @constructor IssueLinkClient\n */\nfunction IssueLinkClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Creates an issue link between two issues. The user requires the link issue permission for the issue which will\n     * be linked to another issue. The specified link type in the request is used to create the link and will create a\n     * link from the first issue to the second issue using the outward description. It also create a link from the\n     * second issue to the first issue using the inward description of the issue link type. It will add the supplied\n     * comment to the first issue. The comment can have a restriction who can view it. If group is specified, only\n     * users of this group can view this comment, if roleLevel is specified only users who have the specified role can\n     * view this comment. The user who creates the issue link needs to belong to the specified group or have the\n     * specified role.\n     *\n     * @memberOf IssueLinkClient#\n     * @method createIssueLink\n     * @param opts The options for the request sent to the Jira API\n     * @param opts.issueLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e5010}\n     * @param [callback] Called when the link has been created.\n     * @return {Promise} Resolved when the link has been created.\n     */\n    this.createIssueLink = function (opts, callback) {\n        if (!opts.issueLink) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_ERROR);\n        }\n\n        var options = {\n            method: 'POST',\n            uri: this.jiraClient.buildURL('/issueLink'),\n            json: true,\n            followAllRedirects: true,\n            body: opts.issueLink\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Issue Link Created');\n    };\n\n    /**\n     * Gets an issue link with the specified id.\n     *\n     * @method getIssueLink\n     * @memberOf IssueLinkClient#\n     * @param opts The options used in the request to the Jira API\n     * @param opts.linkId The id of the link to retrieve.\n     * @param [callback] Called when the Issue Link has been retrieved.\n     * @return {Promise} Resolved when the Issue Link has been retrieved.\n     */\n    this.getIssueLink = function (opts, callback) {\n        if (!opts.linkId) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_ID_ERROR);\n        }\n\n        var options = {\n            method: 'GET',\n            uri: this.jiraClient.buildURL('/issueLink/' + opts.linkId),\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Deletes an issue link with the specified id. To be able to delete an issue link you must be able to view both\n     * issues and must have the link issue permission for at least one of the issues.\n     *\n     * @method deleteIssueLink\n     * @memberOf IssueLinkClient#\n     * @param opts The options used in the request to the Jira API\n     * @param opts.linkId The id of the link to delete.\n     * @param [callback] Called when the Issue Link has been deleted.\n     * @return {Promise} Resolved when the Issue Link has been deleted.\n     */\n    this.deleteIssueLink = function (opts, callback) {\n        if (!opts.linkId) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_ID_ERROR);\n        }\n\n        var options = {\n            method: 'DELETE',\n            uri: this.jiraClient.buildURL('/issueLink/' + opts.linkId),\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'Issue Link Deleted');\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/issueLinkType.js":"\"use strict\";\n\nvar errorStrings = require('./../lib/error');\n\nmodule.exports = IssueLinkTypeClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/issueLinkType'\n * @param {JiraClient} jiraClient\n * @constructor IssueLinkTypeClient\n */\nfunction IssueLinkTypeClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Get a list of available issue link types, if issue linking is enabled. Each issue link type has an id, a name\n     * and a label for the outward and inward link relationship.\n     *\n     * @method getAvailableTypes\n     * @memberOf IssueLinkTypeClient#\n     * @param opts The request options for the API.  Ignored in this function.\n     * @param [callback] Called when the available IssueLink types are retrieved.\n     * @return {Promise} Resolved when the available IssueLink types are retrieved.\n     */\n    this.getAvailableTypes = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issueLinkType'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Create a new issue link type.\n     *\n     * @method createIssueLinkType\n     * @memberOf IssueLinkTypeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.linkType See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2018}\n     * @param [callback] Called when the IssueLink type has been created.\n     * @return {Promise} Resolved when the IssueLink type has been created.\n     */\n    this.createIssueLinkType = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issueLinkType'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.linkType\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Gets for a given issue link type id all information about this issue link type.\n     *\n     * @method getIssueLinkType\n     * @memberOf IssueLinkTypeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.issueLinkTypeId The id of the IssueLink type to retrieve.\n     * @param [callback] Called when the IssueLink type has been retrieved\n     * @return {Promise} Resolved when the IssueLink type has been retrieved\n     */\n    this.getIssueLinkType = function (opts, callback) {\n        if (!opts.issueLinkTypeId) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete the specified issue link type.\n     *\n     * @method deleteIssueLinkType\n     * @memberOf IssueLinkTypeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.issueLinkTypeId The id of the IssueLink type to delete.\n     * @param [callback] Called when the IssueLink type has been delete\n     * @return {Promise} Resolved when the IssueLink type has been delete\n     */\n    this.deleteIssueLinkType = function (opts, callback) {\n        if (!opts.issueLinkTypeId) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'IssueLink type deleted.');\n    };\n\n    /**\n     * Update the specified issue link type.\n     *\n     * @method editIssueLinkType\n     * @memberOf IssueLinkTypeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.issueLinkTypeId The id of the IssueLink type to retrieve.\n     * @param opts.linkType See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2071}\n     * @param [callback] Called when the IssueLink type has been updated.\n     * @return {Promise} Resolved when the IssueLink type has been updated.\n     */\n    this.editIssueLinkType = function (opts, callback) {\n        if (!opts.issueLinkTypeId) {\n            throw new Error(errorStrings.NO_ISSUE_LINK_TYPE_ID);\n        }\n\n        var options = {\n            uri: this.jiraClient.buildURL('/issueLinkType/' + opts.issueLinkTypeId),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.issueLinkType\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/issueType.js":"\"use strict\";\n\nmodule.exports = IssueTypeClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/issuetype'\n *\n * @param {JiraClient} jiraClient\n * @constructor IssueTypeClient\n */\nfunction IssueTypeClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all issue types visible to the user\n     *\n     * @method getAllIssueTypes\n     * @memberOf IssueTypeClient#\n     * @param opts Ignored\n     * @param [callback] Called when the issue types have been retrieved.\n     * @return {Promise} Resolved when the issue types have been retrieved.\n     */\n    this.getAllIssueTypes = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issuetype'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the issue type that has the given id.\n     *\n     * @method getIssueType\n     * @memberOf IssueTypeClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.issueTypeId A String containing an issue type id\n     * @param [callback] Called when the issue type has been retrieved.\n     * @return {Promise} Resolved when the issue type has been retrieved.\n     */\n    this.getIssueType = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/issuetype/' + opts.issueTypeId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/jql.js":"\"use strict\";\n\nmodule.exports = JqlClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/jql/autocompletedata'\n *\n * @param {JiraClient} jiraClient\n * @constructor JqlClient\n */\nfunction JqlClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns the auto complete data required for JQL searches.\n     *\n     * @method getAutoCompleteData\n     * @memberOf JqlClient#\n     * @param opts The options sent to the Jira API.  Ignored by this function.\n     * @param [callback] Called when the autocomplete data is returned.\n     * @return {Promise} Resolved when the autocomplete data is returned.\n     */\n    this.getAutoCompleteData = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/jql/autocompletedata'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback)\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/licenseRole.js":"\"use strict\";\n\nmodule.exports = LicenseRoleClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/licenserole'\n * @param {JiraClient} jiraClient\n * @constructor LicenseRoleClient\n */\nfunction LicenseRoleClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns all license roles in the system.\n     *\n     * @method getAllLicenseRoles\n     * @memberOf LicenseRoleClient#\n     * @param opts Ignored\n     * @param [callback] Called when the license roles have been retrieved.\n     * @return {Promise} Resolved when the license roles have been retrieved.\n     */\n    this.getAllLicenseRoles = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/licenserole'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Gets the passed license role if it exists.\n     *\n     * @method getLicenseRole\n     * @memberOf LicenseRoleClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.roleId The id of the license role to retrieve.\n     * @param [callback] Called when the license role is retrieved.\n     * @return {Promise} Resolved when the license role is retrieved.\n     */\n    this.getLicenseRole = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/licenserole/' + opts.roleId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates the license role with the passed data. Only the groups of the role may be updated. Requests to change\n     * the id or the name of the role will be silently ignored.\n     *\n     * @method editLicenseRole\n     * @memberOf LicenseRoleClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.roleId The id of the license role to retrieve.\n     * @param opts.role The new data to place in the role.  See\n     *  {@link https://docs.atlassian.com/jira/REST/latest/#d2e365}\n     * @param [callback] Called when the license role is edited.\n     * @return {Promise} Resolved when the license role is edited.\n     */\n    this.editLicenseRole = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/licenserole/' + opts.roleId),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.role\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/licenseValidator.js":"\"use strict\";\n\nmodule.exports = LicenseValidatorClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/licenseValidator'\n *\n * @param {JiraClient} jiraClient\n * @constructor LicenseValidatorClient\n */\nfunction LicenseValidatorClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     *\n     * @method validateLicense\n     * @memberOf LicenseValidatorClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.license The license to validate.\n     * @param [callback] Called when the license has been validated, or fails to validate.\n     * @return {Promise} Resolved when the license has been validated, or fails to validate.\n     */\n    this.validateLicense = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/licenseValidator'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.license\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/myPermissions.js":"\"use strict\";\n\nmodule.exports = MyPermissionsClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/mypermissions'\n *\n * @param {JiraClient} jiraClient\n * @constructor MyPermissionsClient\n */\nfunction MyPermissionsClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns all permissions in the system and whether the currently logged in user has them. You can optionally\n     * provide a specific context to get permissions for (projectKey OR projectId OR issueKey OR issueId)\n     *\n     * * When no context supplied the project related permissions will return true if the user has that permission in\n     * ANY project\n     * * If a project context is provided, project related permissions will return true if the user has the permissions\n     * in the specified project. For permissions that are determined using issue data (e.g Current Assignee), true will\n     * be returned if the user meets the permission criteria in ANY issue in that project\n     * * If an issue context is provided, it will return whether or not the user has each permission in that specific\n     * issue\n     *\n     * NB: The above means that for issue-level permissions (EDIT_ISSUE for example), hasPermission may be true when no\n     * context is provided, or when a project context is provided, but may be false for any given (or all) issues. This\n     * would occur (for example) if Reporters were given the EDIT_ISSUE permission. This is because any user could be a\n     * reporter, except in the context of a concrete issue, where the reporter is known.\n     *\n     * Global permissions will still be returned for all scopes.\n     *\n     * @method getMyPermissions\n     * @memberOf MyPermissionsClient#\n     * @param opts The request options sent to the Jira API\n     * @param [callback] Called when the permissions have been returned.\n     * @return {Promise} Resolved when the permissions have been returned.\n     */\n    this.getMyPermissions = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/mypermissions'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/myPreferences.js":"\"use strict\";\n\nmodule.exports = MyPreferencesClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/mypreferences'\n *\n * @param {JiraClient} jiraClient\n * @constructor MyPreferencesClient\n */\nfunction MyPreferencesClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Gets preference of the currently logged in user. Preference key must be provided as input parameter (key).\n     * The value is returned exactly as it is.\n     *\n     * @method getPreference\n     * @memberOf MyPreferencesClient#\n     * @param opts The request options send to the Jira API.\n     * @param opts.key Key of the preference to be returned.\n     * @param [callback] Called when the preference has been retrieved.\n     * @return {Promise} Resolved when the preference has been retrieved.\n     */\n    this.getPreference = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/mypreferences'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                key: opts.key\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets preference of the currently logged in user. Preference key must be provided as input parameters (key).\n     *\n     * @method editPreference\n     * @memberOf MyPreferencesClient#\n     * @param opts The request options send to the Jira API.\n     * @param opts.key Key of the preference to be edited.\n     * @param opts.value The new value to set for the preference.\n     * @param [callback] Called when the preference has been edited.\n     * @return {Promise} Resolved when the preference has been edited.\n     */\n    this.editPreference = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/mypreferences'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                key: opts.key\n            },\n            body: opts.value\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Removes preference of the currently logged in user. Preference key must be provided as input parameters (key).\n     *\n     * @method deletePreference\n     * @memberOf MyPreferencesClient#\n     * @param opts The request options send to the Jira API.\n     * @param opts.key Key of the preference to be deleted.\n     * @param [callback] Called when the preference has been deleted.\n     * @return {Promise} Resolved when the preference has been deleted.\n     */\n    this.deletePreference = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/mypreferences'),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                key: opts.key\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/myself.js":"\"use strict\";\n\nmodule.exports = MyselfClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/myself'\n *\n * @param {JiraClient} jiraClient\n * @constructor MyselfClient\n */\nfunction MyselfClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns currently logged user. This resource cannot be accessed anonymously.\n     *\n     * @method getMyself\n     * @memberOf MyselfClient#\n     * @param opts Ignored\n     * @param [callback] Called when the current user is retrieved.\n     * @return {Promise} Resolved when the current user is retrieved.\n     */\n    this.getMyself = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/myself'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify currently logged user. The \"value\" fields present will override the existing value. Fields skipped in\n     * request will not be changed. Only email and display name can be change that way.\n     *\n     * @method editMyself\n     * @memberOf MyselfClient#\n     * @param opts The request options send to the Jira API.\n     * @param opts.newData The new data.  See {@link https://docs.atlassian.com/jira/REST/latest/#d2e1242}\n     * @param [callback] Called when the user's data has been modified\n     * @return {Promise} Resolved when the user's data has been modified\n     */\n    this.editMyself = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/myself'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.newData\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify caller password.\n     *\n     * @method changePassword\n     * @memberOf MyselfClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.newData The new data\n     * @param [callback] Called when the password has been changed.\n     * @return {Promise} Resolved when the password has been changed.\n     */\n    this.changePassword = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/myself/password'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.newData\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/lib/oauth_util.js":"\"use strict\";\n\n// npm packages\nvar Oauth = require('oauth');\n\n// Core packages\nvar url = require('url');\n\n// Custom Packages\nvar errorStrings = require('./error');\n\n/**\n * @namespace OauthUtil\n */\n\n/**\n * Attempts to get an OAuth verification URL using the given API configuration.\n *\n * @memberOf OauthUtil\n * @param {Object} config The information needed to access the Jira API\n * @param {string} config.host The hostname of the Jira API.\n * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.\n * @param {number} [config.port=443] - The port number used to connect to Jira.\n * @param {string} [config.path_prefix=\"/\"] The prefix to use in front of the path, if Jira isn't at \"/\"\n * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only\n *     version 2 is supported.\n * @param {Object} config.oauth The oauth information\n * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.\n * @param {string} config.oauth.private_key The private key of the application accessing Jira.\n * @param {string} [config.oauth.callback_url] The callback URL to be called after the token is generated.  If this is\n *     not included, the user will be given a verification code after authorizing the token, instead of Jira making a\n *     callback to the application.\n * @param {OauthUtil~getOauthUrlCallback} callback The function called when the URL has been retrieved.\n */\nexports.getAuthorizeURL = function (config, callback) {\n    var prefix = config.path_prefix ? config.path_prefix : '';\n    var AUTH_TOKEN_APPEND = '/oauth/authorize';\n    var SERVLET_BASE_URL = prefix + '/plugins/servlet';\n\n    var authURL = url.format({\n        protocol: config.protocol ? config.protocol : 'https',\n        hostname: config.host,\n        port: config.port ? config.port : null,\n        pathname: SERVLET_BASE_URL + AUTH_TOKEN_APPEND\n    });\n\n    var oauth = generateOAuthObject(config);\n\n    oauth.getOAuthRequestToken(function (err, token, token_secret) {\n        if (err) {\n            return callback(err);\n        }\n        return callback(null, {url: authURL + \"?oauth_token=\" + token, token: token, token_secret: token_secret});\n    });\n};\n\n/**\n * Given an OAuth token, the token secret, and an access verification code (provided by Jira), swap an OAuth request\n * token with an OAuth access token.\n *\n * @memberOf OauthUtil\n * @param {Object} config The information needed to access the Jira API\n * @param {string} config.host The hostname of the Jira API.\n * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.\n * @param {number} [config.port=443] - The port number used to connect to Jira.\n * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only\n *     version 2 is supported.\n * @param {Object} config.oauth The oauth information\n * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.\n * @param {string} config.oauth.private_key The private key of the application accessing Jira.\n * @param {string} config.oauth.token The OAuth Token supplied by Jira.\n * @param {string} config.oauth.token_secret The OAuth Token secret supplied by Jira.\n * @param {string} config.oauth.oauth_verifier The verified code given to the user after authorizing the OAuth token.\n * @param {OauthUtil~swapRequestTokenCallback} callback The function called when the token has been swapped.\n */\nexports.swapRequestTokenWithAccessToken = function(config, callback) {\n    if(!config.oauth.oauth_verifier) {\n        throw new Error(errorStrings.NO_VERIFIER_ERROR);\n    }\n\n    var oauth = generateOAuthObject(config);\n\n    var token = config.oauth.token;\n    var secret = config.oauth.token_secret;\n    var verifier = config.oauth.oauth_verifier;\n\n    oauth.getOAuthAccessToken(token, secret, verifier, callback);\n};\n\n/**\n * Utility function to generate an OAuth object.\n *\n * @memberOf OauthUtil\n * @param {Object} config The information needed to access the Jira API\n * @param {string} config.host The hostname of the Jira API.\n * @param {string} [config.protocol=https] - The protocol used to accses the Jira API.\n * @param {number} [config.port=443] - The port number used to connect to Jira.\n * @param {string} [config.path_prefix=\"/\"] The prefix to use in front of the path, if Jira isn't at \"/\"\n * @param {string} [config.version=2] - The version of the Jira API to which you will be connecting.  Currently, only\n *     version 2 is supported.\n * @param {Object} config.oauth The oauth information\n * @param {string} config.oauth.consumer_key The consumer key of the application accessing Jira.\n * @param {string} config.oauth.private_key The private key of the application accessing Jira.\n * @param {string} [config.oauth.callback_url] The callback URL to be called after the token is generated.  If this is\n *     not included, the user will be given a verification code after authorizing the token, instead of Jira making a\n *     callback to the application.\n *\n * @returns {exports.OAuth} The generated object.\n */\nfunction generateOAuthObject(config) {\n    var prefix = config.path_prefix ? config.path_prefix : '';\n    var SERVLET_BASE_URL = prefix + '/plugins/servlet';\n    var REQ_TOKEN_APPEND = '/oauth/request-token';\n\n    var ACCESS_TOKEN_APPEND = '/oauth/access-token';\n    var sig = 'RSA-SHA1';\n\n    if (!config.host) {\n        throw new Error(errorStrings.NO_HOST_ERROR);\n    } else if (!config.oauth.consumer_key) {\n        throw new Error(errorStrings.NO_CONSUMER_KEY_ERROR);\n    } else if (!config.oauth.private_key) {\n        throw new Error(errorStrings.NO_PRIVATE_KEY_ERROR);\n    }\n\n    var consumer_key = config.oauth.consumer_key;\n    var private_key = config.oauth.private_key;\n\n    var reqURL = url.format({\n        protocol: config.protocol ? config.protocol : 'https',\n        hostname: config.host,\n        port: config.port ? config.port : null,\n        pathname: SERVLET_BASE_URL + REQ_TOKEN_APPEND\n    });\n\n    var accessURL = url.format({\n        protocol: config.protocol ? config.protocol : 'https',\n        hostname: config.host,\n        port: config.port ? config.port : null,\n        pathname: SERVLET_BASE_URL + ACCESS_TOKEN_APPEND\n    });\n\n    var cb = config.oauth.callback_url ? config.oauth.callback_url : 'oob';\n\n    return new Oauth.OAuth(reqURL, accessURL, consumer_key, private_key, '1.0', cb, sig);\n}\n\n/**\n * Callback used by getOauthUrl.\n * @callback OauthUtil~getOauthUrlCallback\n * @param {*} error The error which occurred, if any.\n * @param {Object} oauth The OAuth information retrieved from the Jira API.\n * @param {String} oauth.url The URL that should be visited by the user to verify the OAuth access.\n * @param {String} oauth.token The OAuth Token retrieved from the Jira API.\n * @param {String} oauth.token_secret The OAuth Token Secret retrieved from the Jira API.\n */\n\n/**\n * Callback used by swapRequestTokenWithAccessToken\n * @callback OauthUtil~swapRequestTokenCallback\n * @param {*} error The error which occurred, if any.\n * @param {string} access_token The access token retrieved from Jira.\n */\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/password.js":"\"use strict\";\n\nmodule.exports = PasswordClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/password'\n *\n * @param {JiraClient} jiraClient\n * @constructor PasswordClient\n */\nfunction PasswordClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns user-friendly statements governing the system's password policy.\n     *\n     * @method getPasswordPolicy\n     * @memberOf PasswordClient#\n     * @param opts The request options to send to the Jira API\n     * @param {boolean} [opts.hasOldPassword=false] Whether or not the user will be required to enter their current\n     *     password. Use false (the default) if this is a new user or if an administrator is forcibly changing another\n     *     user's password.\n     * @param [callback] Called when the password policy has been retrieved.\n     * @return {Promise} Resolved when the password policy has been retrieved.\n     */\n    this.getPasswordPolicy = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/password/policy'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                hasOldPassword: opts.hasOldPassword\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/priority.js":"\"use strict\";\n\nmodule.exports = PriorityClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/priority'\n *\n * @param {JiraClient} jiraClient\n * @constructor PriorityClient\n */\nfunction PriorityClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all priorities visible to the user\n     *\n     * @method getAllPriorities\n     * @memberOf PriorityClient#\n     * @param opts Ignored\n     * @param [callback] Called when the priorities have been retrieved.\n     * @return {Promise} Resolved when the priorities have been retrieved.\n     */\n    this.getAllPriorities = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/priority'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the priority that has the given id.\n     *\n     * @method getPriority\n     * @memberOf PriorityClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.priorityId A String containing a priority id\n     * @param [callback] Called when the priority has been retrieved.\n     * @return {Promise} Resolved when the priority has been retrieved.\n     */\n    this.getPriority = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/priority/' + opts.priorityId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/project.js":"\"use strict\";\n\nmodule.exports = ProjectClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/project'\n * @param {JiraClient} jiraClient\n * @constructor ProjectClient\n */\nfunction ProjectClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns all projects which are visible for the currently logged in user. If no user is logged in, it returns the\n     * list of projects that are visible when using anonymous access.\n     *\n     * @method getAllProjects\n     * @memberOf ProjectClient#\n     * @param opts Ignored\n     * @param [callback] Called when the projects have been retrieved.\n     * @return {Promise} Resolved when the projects have been retrieved.\n     */\n    this.getAllProjects = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/project'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Deletes a project \n     *\n     * @method deleteProject\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the project has been deleted.\n     * @return {Promise} Resolved when the project has been deleted.\n     */\n    this.deleteProject = function(opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Project Deleted');\n    };\n\n    /**\n     * Creates a project.\n     *\n     * @method createProject\n     * @memberOf ProjectClient#\n     * @param project The project properties. See {@link https://docs.atlassian.com/jira/REST/latest/#api/2/project}\n     * @param [callback] Called when the project has been created.\n     * @return {Promise} Resolved when the project has been created.\n     */\n    this.createProject = function (project, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/project'),\n            method: 'POST',\n            followAllRedirects: true,\n            json: true,\n            body: project\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Gets project propertes.\n     *\n     * @method getProjectProperties\n     * @memberOf ProjectClient#\n     * @param opts Options\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when properties has been retrieved.\n     * @return {Promise} Resolved when properties has been retrieved.\n     */\n    this.getProjectProperties = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/properties', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n\n\n\n    /**\n     * Contains a full representation of a project in JSON format.\n     *\n     * All project keys associated with the project will only be returned if expand=projectKeys.\n     *\n     * @method getProject\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the project is retrieved.\n     * @return {Promise} Resolved when the project is retrieved.\n     */\n    this.getProject = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Contains a full representation of a the specified project's components.\n     *\n     * @method getComponents\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the components are retrieved.\n     * @return {Promise} Resolved when the components are retrieved.\n     */\n    this.getComponents = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/components', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get all issue types with valid status values for a project\n     *\n     * @method getStatuses\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the statuses have been retrieved.\n     * @return {Promise} Resolved when the statuses have been retrieved.\n     */\n    this.getStatuses = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/statuses', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Contains a full representation of a the specified project's versions.\n     *\n     * @method getVersions\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the versions have been retrieved.\n     * @return {Promise} Resolved when the versions have been retrieved.\n     */\n    this.getVersions = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/versions', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Contains a list of roles in this project with links to full details.\n     *\n     * @method getRoles\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param [callback] Called when the roles have been retrieved.\n     * @return {Promise} Resolved when the roles have been retrieved.\n     */\n    this.getRoles = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/role', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Details on a given project role.\n     *\n     * @method getRole\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param opts.roleId The id of the role to retrieve.\n     * @param [callback] Called when the roles have been retrieved.\n     * @return {Promise} Resolved when the roles have been retrieved.\n     */\n    this.getRole = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Updates a project role to contain the sent actors.\n     *\n     * @method updateRole\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param opts.roleId The id of the role to retrieve.\n     * @param opts.newRole See {@link https://docs.atlassian.com/jira/REST/latest/#d2e108}\n     * @param [callback] Called when the roles have been retrieved.\n     * @return {Promise} Resolved when the roles have been retrieved.\n     */\n    this.updateRole = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'PUT', opts.newRole);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Add an actor to a project role.\n     *\n     * @method addToRole\n     * @memberOf ProjectClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectIdOrKey The project id or project key\n     * @param opts.roleId The id of the role to retrieve.\n     * @param opts.newRole See {@link https://docs.atlassian.com/jira/REST/latest/#d2e134}\n     * @param [callback] Called when the roles have been retrieved.\n     * @return {Promise} Resolved when the roles have been retrieved.\n     */\n    this.addToRole = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/role/' + opts.roleId, 'POST', opts.newRole);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf ProjectClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {number} opts.projectIdOrKey The id of the project to use in the path.\n     * @param {Array} [opts.fields] The fields to include\n     * @param {Array} [opts.expand] The fields to expand\n     * @param {string} path The path of the endpoint following /project/{id}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        var basePath = '/project/' + opts.projectIdOrKey;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n            qs.fields = qs.fields.slice(0, -1);\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n            qs.expand = qs.expand.slice(0, -1);\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/projectCategory.js":"\"use strict\";\n\nmodule.exports = ProjectCategoryClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/projectCategory'\n *\n * @param {JiraClient} jiraClient\n * @constructor ProjectCategoryClient\n */\nfunction ProjectCategoryClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all projectCategories visible to the user\n     *\n     * @method getAllProjectCategories\n     * @memberOf ProjectCategoryClient#\n     * @param opts Ignored\n     * @param [callback] Called when the statusCategories have been retrieved.\n     * @return {Promise} Resolved when the statusCategories have been retrieved.\n     */\n    this.getAllProjectCategories = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/projectCategory'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the projectCategory that has the given id.\n     *\n     * @method getProjectCategory\n     * @memberOf ProjectCategoryClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.projectCategoryId A String containing a projectCategory id\n     * @param [callback] Called when the projectCategory has been retrieved.\n     * @return {Promise} Resolved when the projectCategory has been retrieved.\n     */\n    this.getProjectCategory = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/projectCategory/' + opts.projectCategoryId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/projectValidate.js":"\"use strict\";\n\nmodule.exports = ProjectValidateClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/projectvalidate'\n *\n * @param {JiraClient} jiraClient\n * @constructor ProjectValidateClient\n */\nfunction ProjectValidateClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Validates a project key.  This endpoint is a little wonky, as it returns a list of errors as a valid response;\n     * even if the key is invalid, it still returns a 200 response.\n     * See {@link https://docs.atlassian.com/jira/REST/latest/#d2e297}\n     *\n     * @method validateProjectKey\n     * @memberOf ProjectValidateClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.projectKey The key of the project.\n     * @param [callback] Called when the key has been validated.\n     * @return {Promise} Resolved when the key has been validated.\n     */\n    this.validateProjectKey = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/projectvalidate/key'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                key: opts.projectKey\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/reindex.js":"\"use strict\";\n\nmodule.exports = ReindexClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/reindex'\n *\n * @param {JiraClient} jiraClient\n * @constructor ReindexClient\n */\nfunction ReindexClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Kicks off a reindex. Need Admin permissions to perform this reindex.\n     *\n     * @method doReindex\n     * @memberOf ReindexClient#\n     * @param opts The request options sent to the Jira API.\n     * @param {string} [opts.type] Case insensitive String indicating type of reindex. If omitted, then defaults to\n     *     BACKGROUND_PREFERRED\n     * @param {boolean} [opts.indexComments=false] Indicates that comments should also be reindexed. Not relevant for\n     *     foreground reindex, where comments are always reindexed.\n     * @param {boolean} [opts.indexChangeHistory=false] Indicates that changeHistory should also be reindexed. Not\n     *     relevant for foreground reindex, where changeHistory is always reindexed.\n     * @param [callback] Called when the reindex has been started.\n     * @return {Promise} Resolved when the reindex has been started.\n     */\n    this.doReindex = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/reindex'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                type: opts.type,\n                indexComments: opts.indexComments,\n                indexChangeHistory: opts.indexChangeHistory\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Gets information on the system reindexes. If a reindex is currently taking place then information about this\n     * reindex is returned. If there is no active index task, then returns information about the latest reindex task\n     * run, otherwise returns a 404 indicating that no reindex has taken place.\n     *\n     * @method getReindex\n     * @memberOf ReindexClient#\n     * @param opts The request options sent to the Jira API.\n     * @param [opts.taskId] The id of an indexing task you wish to obtain details on. If omitted, then defaults to the\n     *     standard behaviour and returns information on the active reindex task, or the last task to run if no reindex\n     *     is taking place. . If there is no reindexing task with that id then a 404 is returned.\n     * @param [callback] Called when the reindex data has been retrieved.\n     * @return {Promise} Resolved when the reindex data has been retrieved.\n     */\n    this.getReindex = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/reindex'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                taskId: opts.taskId\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/resolution.js":"\"use strict\";\n\nmodule.exports = ResolutionClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/resolution'\n *\n * @param {JiraClient} jiraClient\n * @constructor ResolutionClient\n */\nfunction ResolutionClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all resolutions visible to the user\n     *\n     * @method getAllResolutions\n     * @memberOf ResolutionClient#\n     * @param opts Ignored\n     * @param [callback] Called when the resolutions have been retrieved.\n     * @return {Promise} Resolved when the resolutions have been retrieved.\n     */\n    this.getAllResolutions = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/resolution'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the resolution that has the given id.\n     *\n     * @method getResolution\n     * @memberOf ResolutionClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.resolutionId A String containing a resolution id\n     * @param [callback] Called when the resolution has been retrieved.\n     * @return {Promise} Resolved when the resolution has been retrieved.\n     */\n    this.getResolution = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/resolution/' + opts.resolutionId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/screens.js":"\"use strict\";\n\nmodule.exports = ScreensClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/screens'\n *\n * @param {JiraClient} jiraClient\n * @constructor ScreensClient\n */\nfunction ScreensClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Gets available fields for screen. i.e ones that haven't already been added.\n     *\n     * @method getAvailableFields\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to Jira\n     * @param {number} opts.screenId The id of the screen to retrieve.\n     * @param [callback] Called when the available fields have been retrieved\n     * @return {Promise} Resolved when the available fields have been retrieved\n     */\n    this.getAvailableFields = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/availableFields', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of all tabs for the given screen.\n     *\n     * @method getTabs\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to Jira\n     * @param {number} opts.screenId The id of the screen to retrieve.\n     * @param [callback] Called when the tabs have been retrieved.\n     * @return {Promise} Resolved when the tabs have been retrieved.\n     */\n    this.getTabs = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates tab for given screen\n     *\n     * @method createTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to Jira\n     * @param {number} opts.screenId The id of the screen in which to create a tab.\n     * @param {string} opts.name The name of the tab to add.  Minimum required to create a tab.\n     * @param [callback] Called when the tab has been created.\n     * @return {Promise} Resolved when the tab has been created.\n     */\n    this.createTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs', 'POST', {name: opts.name});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Renames the given tab on the given screen.\n     *\n     * @method renameTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the jira API\n     * @param {number} opts.screenId The id of the screen containing the tab to rename.\n     * @param {number} opts.tabId The id of the tab to rename\n     * @param {string} opts.name The new name of the tab.\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.renameTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId, 'PUT', {name: opts.name});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Deletes the given tab from the given screen.\n     *\n     * @method deleteTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the jira API\n     * @param {number} opts.screenId The id of the screen containing the tab to delete.\n     * @param {number} opts.tabId The id of the tab to delete\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.deleteTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Tab Deleted');\n    };\n\n    /**\n     * Adds field to the given tab\n     *\n     * @method addFieldToTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.screenId The id of the screen containing the tab.\n     * @param {number} opts.tabId the id of the tab to which the fields will be added.\n     * @param {string} opts.fieldId The field to add\n     * @param [callback] Called when the fields have been added to the tab.\n     * @return {Promise} Resolved when the fields have been added to the tab.\n     */\n    this.addFieldToTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields', 'POST', opts.fieldId);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Gets all fields for a given tab.\n     *\n     * @method getFieldsInTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.screenId The id of the screen containing the tab.\n     * @param {number} opts.tabId the id of the tab for which to retrieve fields.\n     * @param [callback] Called when the fields have been retrieved.\n     * @return {Promise} Resolved when the fields have been retrieved.\n     */\n    this.getFieldsInTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the given field from the given tab.\n     *\n     * @method removeFieldFromTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.screenId The id of the screen containing the tab.\n     * @param {number} opts.tabId the id of the tab from which to remove the field.\n     * @param {string} opts.fieldId The id of the field to remove from the tab.\n     * @param [callback] Called when the field has been removed.\n     * @return {Promise} Resolved when the field has been removed.\n     */\n    this.removeFieldFromTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields/' + opts.fieldId, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Field Removed From Tab');\n    };\n\n    /**\n     * Move the given field on the given tab\n     *\n     * @method moveFieldOnTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.screenId The id of the screen containing the tab.\n     * @param {number} opts.tabId the id of the tab containing the field.\n     * @param {string} opts.fieldId The id of the field to remove from the tab.\n     * @param {number} opts.newPosition The position to which the field should be moved.  May be one of:\n     *  * Earlier\n     *  * Later\n     *  * First\n     *  * Last\n     * @param [callback] Called when the field has been removed.\n     * @return {Promise} Resolved when the field has been removed.\n     */\n    this.moveFieldOnTab = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/fields/' + opts.fieldId + '/move',\n            'POST', {position: opts.newPosition});\n        return this.jiraClient.makeRequest(options, callback, 'Field Moved');\n    };\n\n    /**\n     * Moves tab position\n     *\n     * @method moveTabPosition\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {number} opts.screenId The id of the screen containing the tab.\n     * @param {number} opts.tabId the id of the tab to move.\n     * @param {number} opts.newPosition The new (zero-indexed) position of the tab.\n     * @param [callback] Called when the tab has been moved.\n     * @return {Promise} Resolved when the tab has been moved.\n     */\n    this.moveTabPosition = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/tabs/' + opts.tabId + '/move/' + opts.newPosition, 'POST');\n        return this.jiraClient.makeRequest(options, callback, 'Tab Moved');\n    };\n\n    /**\n     * Adds field or custom field to the default tab\n     *\n     * @method addFieldToDefaultTab\n     * @memberOf ScreensClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string} opts.fieldId The id of the field to add to the default tab.\n     * @param [callback] Called when the tab has been moved.\n     * @return {Promise} Resolved when the tab has been moved.\n     */\n    this.addFieldToDefaultTab = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/screens/addToDefault/' + opts.fieldId),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf FilterClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {number} opts.screenId The id of the screen to use in the path.\n     * @param {Array} [opts.fields] The fields to include\n     * @param {Array} [opts.expand] The fields to expand\n     * @param {string} path The path of the endpoint following /screen/{id}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        var basePath = '/screens/' + opts.screenId;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n            qs.fields = qs.fields.slice(0, -1);\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n            qs.expand = qs.expand.slice(0, -1);\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/search.js":"\"use strict\";\n\nmodule.exports = SearchClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/search'\n *\n * @param {JiraClient} jiraClient\n * @constructor SearchClient\n */\nfunction SearchClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Searches for issues using JQL.\n     *\n     * Sorting the jql parameter is a full JQL expression, and includes an ORDER BY clause.\n     *\n     * The fields param (which can be specified multiple times) gives a comma-separated list of fields to include in\n     * the response. This can be used to retrieve a subset of fields. A particular field can be excluded by prefixing\n     * it with a minus.\n     *\n     * By default, only navigable (*navigable) fields are returned in this search resource. Note: the default is\n     * different in the get-issue resource -- the default there all fields (*all).\n     *\n     * * *all - include all fields\n     * * navigable - include just navigable fields\n     * * summary,comment - include just the summary and comments\n     * * -description - include navigable fields except the description (the default is *navigable for search)\n     * * *all,-comment - include everything except comments\n     *\n     * Expanding Issues in the Search Result: It is possible to expand the issues returned by directly specifying the\n     * expansion on the expand parameter passed in to this resources.\n     *\n     * For instance, to expand the \"changelog\" for all the issues on the search result, it is neccesary to specify\n     * \"changelog\" as one of the values to expand.\n     *\n     * @method search\n     * @memberOf SearchClient#\n     * @param opts The options for the search.\n     * @param {string} opts.jql The JQL query string\n     * @param {number} [opts.startAt] The index of the first issue to return (0-based)\n     * @param {number} [opts.maxResults] The maximum number of issues to return (defaults to 50). The maximum allowable\n     *     value is dictated by the JIRA property 'jira.search.views.default.max'. If you specify a value that is\n     *     higher than this number, your search results will be truncated.\n     * @param {boolean} [opts.validateQuery=true] Whether to validate the JQL query\n     * @param {array} [opts.fields] The list of fields to return for each issue. By default, all navigable fields are\n     *     returned.\n     * @param {array} [opts.expand] A list of the parameters to expand.\n     * @param [callback] Called with the search results.\n     * @return {Promise} Resolved with the search results.\n     */\n    this.search = function (opts, callback) {\n        opts.method = opts.method || 'POST';\n\n        var options = {\n            uri: this.jiraClient.buildURL('/search'),\n            method: opts.method, \n            json: true,\n            followAllRedirects: true\n\n        };\n\n        var search_options = {\n            jql: opts.jql,\n            startAt: opts.startAt,\n            maxResults: opts.maxResults,\n            validateQuery: opts.validateQuery,\n            fields: opts.fields,\n            expand: opts.expand\n        };\n\n        if (opts.method === 'POST') {\n            options.body = search_options;\n        } else {\n            options.qs = search_options;\n        }\n\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/securityLevel.js":"\"use strict\";\n\nmodule.exports = SecurityLevelClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/securitylevel'\n *\n * @param {JiraClient} jiraClient\n * @constructor SecurityLevelClient\n */\nfunction SecurityLevelClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Get a full representation of the security level that has the given id.\n     *\n     * @method getSecurityLevel\n     * @memberOf SecurityLevelClient#\n     * @param opts The request options to send to the Jira API.\n     * @param opts.securityLevelId The id of the security level to retrieve\n     * @param [callback] Called when the security level has been retrieved.\n     * @return {Promise} Resolved when the security level has been retrieved.\n     */\n    this.getSecurityLevel = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/securitylevel/' + opts.securityLevelId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/serverInfo.js":"\"use strict\";\n\nmodule.exports = ServerInfoClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/serverInfo'\n * @param {JiraClient} jiraClient\n * @constructor ServerInfoClient\n */\nfunction ServerInfoClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns general information about the current JIRA server.\n     *\n     * @method getServerInfo\n     * @memberOf ServerInfoClient#\n     * @param opts The request options sent to the Jira API.\n     * @param {boolean} [opts.doHealthCheck] Whether to perform a health check on the server.\n     * @param [callback] Called when the server info has been retrieved.\n     * @return {Promise} Resolved when the server info has been retrieved.\n     */\n    this.getServerInfo = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/serverInfo'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                doHealthCheck: opts.doHealthCheck\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    }\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/settings.js":"\"use strict\";\n\nmodule.exports = SettingsClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/settings'\n * @param {JiraClient} jiraClient\n * @constructor SettingsClient\n */\nfunction SettingsClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Sets the base URL that is configured for this JIRA instance.\n     *\n     * @method setBaseUrl\n     * @memberOf SettingsClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.newUrl The new base url.\n     * @param [callback] Called when the base url has been set.\n     * @return {Promise} Resolved when the base url has been set.\n     */\n    this.setBaseUrl = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/settings/baseUrl'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            body: opts.newUrl\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the default system columns for issue navigator. Admin permission will be required.\n     *\n     * @method getIssueNavColumns\n     * @memberOf SettingsClient#\n     * @param opts Ignored\n     * @param [callback] Called when the columns have been retrieved\n     * @return {Promise} Resolved when the columns have been retrieved\n     */\n    this.getIssueNavColumns = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/settings/columns'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/sprint.js":"\"use strict\";\n\nmodule.exports = AgileSprintClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/agile/1.0/sprint'\n * @param {JiraClient} jiraClient\n * @constructor AgileSprintClient\n */\nfunction AgileSprintClient(jiraClient) {\n  this.jiraClient = jiraClient;\n\n  /**\n   * Creates a sprint from a JSON representation.\n   *\n   * @method createSprint\n   * @memberOf AgileSprintClient#\n   * @param {Object} sprint The sprint data in the form of POST body to the\n   *   Jira API.\n   * @param [callback] Called when the sprint has been created.\n   * @return {Promise} Resolved when the sprint has been created.\n   */\n  this.createSprint = function (sprint, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint'),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: sprint\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Get a single sprint.\n   *\n   * @method getSprint\n   * @memberOf AgileSprintClient#\n   * @param {object} opts The request options sent to the Jira API.\n   * @param opts.sprintId The sprint id.\n   * @param [callback] Called when the sprint has been retrieved.\n   * @return {Promise} Resolved when the sprint has been retrieved.\n   */\n  this.getSprint = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        filter: opts.filter,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Perform a full update of a sprint.\n   *\n   * @method updateSprint\n   * @memberOf AgileSprintClient#\n   * @param {Object} sprint The sprint data in the form of PUT body to the\n   *   Jira API.\n   * @param {string} [sprint.sprintId] The id of the sprint.  EX: 331\n   * @param [callback] Called when the sprint has been updated.\n   * @return {Promise} Resolved when the sprint has been updated.\n   */\n  this.updateSprint = function (sprint, callback) {\n    var sprintId = sprint.sprintId;\n    delete sprint.sprintId;\n\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId),\n      method: 'PUT',\n      followAllRedirects: true,\n      json: true,\n      body: sprint\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Perform a partial update of a sprint.\n   *\n   * @method partiallyUpdateSprint\n   * @memberOf AgileSprintClient#\n   * @param {Object} sprint The sprint data in the form of POST body to the\n   *   Jira API.\n   * @param {string} [sprint.sprintId] The id of the sprint.  EX: 331.\n   * @param callback Called when the sprint has been updated.\n   * @return {Promise} Resolved when the sprint has been updated.\n   */\n  this.partiallyUpdateSprint = function (sprint, callback) {\n    var sprintId = sprint.sprintId;\n    delete sprint.sprintId;\n\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: sprint\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Delete an existing sprint.\n   *\n   * @method deleteSprint\n   * @memberOf AgileSprintClient#\n   * @param {Object} opts The request options sent to the Jira API.\n   * @param {string} opts.sprintId The id of the sprint.  EX: 331\n   * @param [callback] Called when the sprint is deleted.\n   * @return {Promise} Resolved when the sprint is deleted.\n   */\n  this.deleteSprint = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId),\n      method: 'DELETE',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        filter: opts.filter,\n        startAt: opts.startAt,\n        maxResults: opts.maxResults\n      }\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Return all issues in a sprint, for a given sprint id.\n   *\n   * @method getSprintIssues\n   * @memberOf AgileSprintClient#\n   * @param {Object} opts The request options sent to the Jira API.\n   * @param opts.sprintId The sprint id.\n   * @param {string} jql Filters results using a JQL query.\n   * @param {boolean} validateQuery Specifies whether to valide the JQL query.\n   * @param {string} fields The list of fields to return for each issue.\n   * @param {string} expand A comma-separated list of the parameters to expand.\n   * @param [callback] Called when the issues are returned.\n   * @return {Promise} Resolved when the issues are returned.\n   */\n  this.getSprintIssues = function (opts, callback) {\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + opts.sprintId + '/issue'),\n      method: 'GET',\n      json: true,\n      followAllRedirects: true,\n      qs: {\n        startAt: opts.startAt,\n        maxResults: opts.maxResults,\n        jql: opts.jql,\n        validateQuery: opts.validateQuery,\n        fields: opts.fields,\n        expand: opts.expand\n      }\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Move issues to a sprint, for a given sprint id.\n   *\n   * @method moveSprintIssues\n   * @memberOf AgileSprintClient#\n   * @param {Object} opts The issue data in the form of POST body to the\n   *   Jira API.\n   * @param {string} [opts.sprintId] The sprint id.\n   * @param [callback] Called when the sprint has been retrieved.\n   * @return {Promise} Resolved when the sprint has been retrieved.\n   */\n  this.moveSprintIssues = function (opts, callback) {\n    var sprintId = opts.sprintId;\n    delete opts.sprintId;\n\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId + '/issue'),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: opts\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n  /**\n   * Swap the position of the sprint (given by sprint id) with the second\n   * sprint.\n   *\n   * @method swapSprint\n   * @memberOf AgileSprintClient#\n   * @param {Object} swapped The data in the form of POST body to the Jira API.\n   * @param {string} [swapped.sprintId] The id of the sprint.  EX: 311\n   * @param [callback] Called when the sprint has been retrived.\n   * @return {Promise} Resolved when the sprint has been retrived.\n   */\n  this.swapSprint = function (swapped, callback) {\n    var sprintId = swapped.sprintId;\n    delete swapped.sprintId;\n\n    var options = {\n      uri: this.jiraClient.buildAgileURL('/sprint/' + sprintId + '/swap'),\n      method: 'POST',\n      followAllRedirects: true,\n      json: true,\n      body: swapped\n    };\n\n    return this.jiraClient.makeRequest(options, callback);\n  };\n\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/status.js":"\"use strict\";\n\nmodule.exports = StatusClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/status'\n *\n * @param {JiraClient} jiraClient\n * @constructor StatusClient\n */\nfunction StatusClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all statuses visible to the user\n     *\n     * @method getAllStatuses\n     * @memberOf StatusClient#\n     * @param opts Ignored\n     * @param [callback] Called when statuses have been retrieved.\n     * @return {Promise} Resolved when statuses have been retrieved.\n     */\n    this.getAllStatuses = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/status'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the status that has the given id.\n     *\n     * @method getStatus\n     * @memberOf StatusClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.statusId A String containing a status id\n     * @param [callback] Called when the status has been retrieved.\n     * @return {Promise} Resolved when the status has been retrieved.\n     */\n    this.getStatus = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/status/' + opts.statusId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/statusCategory.js":"\"use strict\";\n\nmodule.exports = StatusCategoryClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/statuscategory'\n *\n * @param {JiraClient} jiraClient\n * @constructor StatusCategoryClient\n */\nfunction StatusCategoryClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all statusCategories visible to the user\n     *\n     * @method getAllStatusCategories\n     * @memberOf StatusCategoryClient#\n     * @param opts Ignored\n     * @param [callback] Called when the statusCategories have been retrieved.\n     * @return {Promise} Resolved when the statusCategories have been retrieved.\n     */\n    this.getAllStatusCategories = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/statuscategory'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a full representation of the statusCategory that has the given id or key.\n     *\n     * @method getStatusCategory\n     * @memberOf StatusCategoryClient#\n     * @param opts The options sent to the Jira API\n     * @param opts.statusCategoryIdOrKey A String containing a statusCategory id\n     * @param [callback] Called when the statusCategory has been retrieved.\n     * @return {Promise} Resolved when the statusCategory has been retrieved.\n     */\n    this.getStatusCategory = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/statuscategory/' + opts.statusCategoryIdOrKey),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/user.js":"\"use strict\";\n\nvar fs = require('fs');\nvar path = require('path');\n\nmodule.exports = UserClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/user'\n *\n * @param {JiraClient} jiraClient\n * @constructor UserClient\n */\nfunction UserClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Get a user. This resource cannot be accessed anonymously.\n     *\n     * @method getUser\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.username The name of the user to retrieve.\n     * @param opts.userKey The key of the user to retrieve.\n     * @param {Object} opts.expand The fields to be expanded.\n     * @param [callback] Called when the user has been retrieved.\n     * @return {Promise} Resolved when the user has been retrieved.\n     */\n    this.getUser = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                key: opts.userKey,\n                expand: opts.expand\n            }\n        };\n\n        if (opts.expand) {\n            options.qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                options.qs.expand += ex + ','\n            });\n        }\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Removes user.\n     *\n     * @method deleteUser\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.username The name of the user to delete.\n     * @param opts.userKey The key of the user to delete.\n     * @param [callback] Called when the user has been deleted.\n     * @return {Promise} Resolved when the user has been deleted.\n     */\n    this.deleteUser = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user'),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                key: opts.userKey\n            }\n        };\n\n        return this.jiraClient.makeRequest(options, callback, 'User removed.');\n    };\n\n    /**\n     * Create user. By default created user will not be notified with email. If password field is not set then password\n     * will be randomly generated.\n     *\n     * @method createUser\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.user See {@link https://docs.atlassian.com/jira/REST/latest/#d2e4049}\n     * @param [callback] Called when the user has been created.\n     * @return {Promise} Resolved when the user has been created.\n     */\n    this.createUser = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.user\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify user. The \"value\" fields present will override the existing value. Fields skipped in request will not be\n     * changed.\n     *\n     * @method editUser\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.user See {@link https://docs.atlassian.com/jira/REST/latest/#d2e4081}\n     * @param opts.username The name of the user to edit.\n     * @param opts.userKey The key of the user to edit.\n     * @param [callback] Called when the user has been edited.\n     * @return {Promise} Resolved when the user has been edited.\n     */\n    this.editUser = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                key: opts.userKey\n            },\n            body: opts.user\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of users that match the search string and can be assigned issues for all the given projects. This\n     * resource cannot be accessed anonymously.\n     *\n     * @method multiProjectSearchAssignable\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The name of the user to search.\n     * @param {Array} opts.projectKeys The keys of the projects we are finding assignable users for\n     * @param {number} [opts.startAt] The index of the first user to return (0-based)\n     * @param {number} [opts.maxResults] The maximum number of users to return (defaults to 50). The maximum allowed\n     *     value is 1000. If you specify a value that is higher than this number, your search results will be\n     *     truncated.\n     * @param [callback] Called when the search results have been retrieved.\n     * @return {Promise} Resolved when the search results have been retrieved.\n     */\n    this.multiProjectSearchAssignable = function (opts, callback) {\n        var projectKeyString = '';\n        if (opts.projectKeys) {\n            opts.projectKeys.forEach(function (key) {\n                projectKeyString += key + ',';\n            });\n            projectKeyString = projectKeyString.slice(0, -1);\n        }\n        var options = {\n            uri: this.jiraClient.buildURL('/user/assignable/multiProjectSearch'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                projectKeys: projectKeyString,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of users that match the search string. This resource cannot be accessed anonymously. Please note\n     * that this resource should be called with an issue key when a list of assignable users is retrieved for editing.\n     * For create only a project key should be supplied. The list of assignable users may be incorrect if it's called\n     * with the project key for editing.\n     *\n     * @method searchAssignable\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param {string} opts.project The key of the project we are finding assignable users for\n     * @param {string} [opts.issueKey] The issue key for the issue being edited we need to find assignable users for.\n     * @param {number} [opts.startAt] The index of the first user to return (0-based)\n     * @param {number} [opts.maxResults] The maximum number of users to return (defaults to 50). The maximum allowed\n     *     value is 1000. If you specify a value that is higher than this number, your search results will be\n     *     truncated.\n     * @param {number} [opts.actionDescriptorId]\n     * @param [callback] Called when the search results have been retrieved.\n     * @return {Promise} Resolved when the search results have been retrieved.\n     */\n    this.searchAssignable = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/assignable/search'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                project: opts.project,\n                issueKey: opts.issueKey,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults,\n                actionDescriptorId: opts.actionDescriptorId\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Creates temporary avatar. Creating a temporary avatar is part of a 3-step process in uploading a new avatar for\n     * a user: upload, crop, confirm.\n     *\n     * @method createTemporaryAvatar\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param {string} opts.filepath The path to the file to upload.\n     * @param [callback] Called when the temporary avatar has been uploaded.\n     * @return {Promise} Resolved when the temporary avatar has been uploaded.\n     */\n    this.createTemporaryAvatar = function (opts, callback) {\n        var extension = path.extname(opts.filepath).slice(1);\n        var baseName = path.basename(opts.filepath);\n        var fileSize = fs.statSync(opts.filepath).size;\n\n        extension = extension == 'jpg' ? 'jpeg' : extension;\n\n        var options = {\n            uri: this.jiraClient.buildURL('/user/avatar/temporary'),\n            method: 'POST',\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                filename: baseName,\n                size: fileSize\n            },\n            body: fs.readFileSync(opts.filepath),\n            headers: {\n                \"X-Atlassian-Token\": 'no-check',\n                \"Content-Type\": 'image/' + extension\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Converts temporary avatar into a real avatar\n     *\n     * @method convertTemporaryAvatar\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param {Object} opts.avatarId The id of the temporary avatar to convert.\n     * @param [callback] Called when the avatar has been converted\n     * @return {Promise} Resolved when the avatar has been converted\n     */\n    this.convertTemporaryAvatar = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/avatar/'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            },\n            body: {id: opts.avatarId},\n            headers: {\n                \"X-Atlassian-Token\": 'no-check'\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback, 'Avatar Converted');\n    };\n\n    /**\n     * Deletes avatar\n     *\n     * @method deleteAvatar\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param {Object} opts.avatarId The id of the temporary avatar to delete.\n     * @param [callback] Called when the avatar has been deleted.\n     * @return {Promise} Resolved when the avatar has been deleted.\n     */\n    this.deleteAvatar = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/avatar/' + opts.avatarId),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback, 'Avatar Deleted');\n    };\n\n    /**\n     * Returns all avatars which are visible for the currently logged in user.\n     *\n     * @method getAvatars\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param [callback] Called when the avatars have been retrieved.\n     * @return {Promise} Resolved when the avatars have been retrieved.\n     */\n    this.getAvatars = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/avatars'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the default columns for the given user. Admin permission will be required to get columns for a user\n     * other than the currently logged in user.\n     *\n     * @method getDefaultColumns\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param [callback] Called when the columns have been retrieved.\n     * @return {Promise} Resolved when the columns have been retrieved.\n     */\n    this.getDefaultColumns = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/columns'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Sets the default columns for the given user. Admin permission will be required to get columns for a user other\n     * than the currently logged in user.\n     *\n     * @method setDefaultColumns\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param {Array} opts.columns The names of the new columns.  See {@link\n        *     https://docs.atlassian.com/jira/REST/latest/#d2e4566}\n     * @param [callback] Called when the columns have been set.\n     * @return {Promise} Resolved when the columns have been set.\n     */\n    this.setDefaultColumns = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/columns'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            },\n            body: {\n                columns: opts.columns\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback, 'Default Columns Set');\n    };\n\n    /**\n     * Reset the default columns for the given user to the system default. Admin permission will be required to get\n     * columns for a user other than the currently logged in user.\n     *\n     * @method resetDefaultColumns\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} opts.username The username\n     * @param [callback] Called when the columns have been reset.\n     * @return {Promise} Resolved when the columns have been reset.\n     */\n    this.resetDefaultColumns = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/columns'),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback, 'Default Columns Reset');\n    };\n\n    /**\n     * Modify user password.\n     *\n     * @method changePassword\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.username The name of the user for which to change the password.\n     * @param opts.userKey The key of the user for which to change the password.\n     * @param opts.password The new password.\n     * @param [callback] Called when the password has been set.\n     * @return {Promise} Resolved when the password has been set.\n     */\n    this.changePassword = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/password'),\n            method: 'PUT',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                key: opts.userKey\n            },\n            body: {\n                password: opts.password\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback, 'Password Changed');\n    };\n\n    /**\n     * Returns a list of active users that match the search string and have all specified permissions for the project\n     * or issue.\n     *\n     * This resource can be accessed by users with ADMINISTER_PROJECT permission for the project or global\n     * ADMIN or SYSADMIN rights.\n     *\n     * @method searchPermissions\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the jira API\n     * @param {string} opts.username The username filter, list includes all users if unspecified\n     * @param {Array} opts.permissions Array of permissions for project or issue returned users must have, see\n     *     [Permissions]{@link\n        *     https://developer.atlassian.com/static/javadoc/jira/6.0/reference/com/atlassian/jira/security/Permissions.Permission.html}\n        *     JavaDoc for the list of all possible permissions.\n     * @param {string} [opts.issueKey] the issue key for the issue for which returned users have specified permissions.\n     * @param {string} [opts.projectKey] the optional project key to search for users with if no issueKey is supplied.\n     * @param {number} [opts.startAt] the index of the first user to return (0-based)\n     * @param {number} [opts.maxResults] the maximum number of users to return (defaults to 50). The maximum allowed\n     *     value is 1000. If you specify a value that is higher than this number, your search results will be\n     *     truncated.\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */\n    this.searchPermissions = function (opts, callback) {\n        var permissions = '';\n        if (opts.permissions) {\n            opts.permissions.forEach(function (s) {\n                permissions += s + ','\n            });\n            permissions = permissions.slice(0, -1);\n        }\n        var options = {\n            uri: this.jiraClient.buildURL('/user/permission/search'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                permissions: permissions,\n                issueKey: opts.issueKey,\n                projectKey: opts.projectKey,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of users matching query with highlighting. This resource cannot be accessed anonymously.\n     *\n     * @method searchPicker\n     * @memberOf UserClient#\n     * @param opts The request options sent to the Jira API.\n     * @param {string} opts.query\n     * @param {number} [opts.maxResults=50]\n     * @param {boolean} [opts.showAvatar=false]\n     * @param {string} [opts.exclude]\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */\n    this.searchPicker = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/picker'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                query: opts.query,\n                maxResults: opts.maxResults,\n                showAvatar: opts.showAvatar,\n                exclude: opts.exclude\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of users that match the search string. This resource cannot be accessed anonymously.\n     *\n     * @method search\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string} opts.username A query string used to search username, name or e-mail address\n     * @param {number} [opts.startAt=0] the index of the first user to return (0-based)\n     * @param {number} [opts.maxResults=50] the maximum number of users to return (defaults to 50). The maximum allowed\n     *     value is 1000. If you specify a value that is higher than this number, your search results will be\n     *     truncated.\n     * @param {boolean} [opts.includeActive=true] If true, then active users are included in the results (default true)\n     * @param {boolean} [opts.includeInactive=false] If true, then inactive users are included in the results (default\n     *     false)\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */\n    this.search = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/search'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                maxResults: opts.maxResults,\n                startAt: opts.startAt,\n                includeActive: opts.includeActive,\n                includeInactive: opts.includeInactive\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a list of active users that match the search string. This resource cannot be accessed anonymously. Given\n     * an issue key this resource will provide a list of users that match the search string and have the browse issue\n     * permission for the issue provided.\n     *\n     * @method viewIssueSearch\n     * @memberOf UserClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string} opts.username A query string used to search username, name or e-mail address\n     * @param {string} [opts.issueKey] the issue key for the issue being edited we need to find viewable users for.\n     * @param {string} [opts.projectKey] the optional project key to search for users with if no issueKey is supplied.\n     * @param {number} [opts.startAt=0] the index of the first user to return (0-based)\n     * @param {number} [opts.maxResults=50] the maximum number of users to return (defaults to 50). The maximum allowed\n     * @param [callback] Called when data has been retrieved\n     * @return {Promise} Resolved when data has been retrieved\n     */\n    this.viewIssueSearch = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/user/viewissue/search'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                username: opts.username,\n                issueKey: opts.issueKey,\n                projectKey: opts.projectKey,\n                startAt: opts.startAt,\n                maxResults: opts.maxResults\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/version.js":"\"use strict\";\n\nmodule.exports = VersionClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/version'\n * @param {JiraClient} jiraClient\n * @constructor VersionClient\n */\nfunction VersionClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Creates a version\n     *\n     * @method createVersion\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to Jira.\n     * @param {Object} opts.version See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3549}\n     * @param [callback] Called when the version has been created.\n     * @return {Promise} Resolved when the version has been created.\n     */\n    this.createVersion = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/version'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.version\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify a version's sequence within a project. The move version bean has 2 alternative field value pairs\n     * (opts.position or opts.after).  One and only one of these two must be provided.\n     *\n     * @method moveVersion\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string} opts.versionId The id of the version to move.\n     * @param {string} [opts.position] An absolute position, which may have a value of 'First', 'Last', 'Earlier' or\n     *     'Later'. Must be provided if opts.after is missing.\n     * @param {string} [opts.after] A version to place this version after. The value should be the self link of another\n     *     version. Must be provided if opts.position is missing\n     * @param [callback] Called when the version has been moved.\n     * @return {Promise} Resolved when the version has been moved.\n     */\n    this.moveVersion = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/move', 'POST', {position: opts.position, after: opts.after});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a project version.\n     *\n     * @method getVersion\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string|number} opts.versionId The id of the version to retrieve.\n     * @param [callback] Called when the version is retrieved.\n     * @return {Promise} Resolved when the version is retrieved.\n     */\n    this.getVersion = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Modify an existing version; any omitted fields will be ignored.\n     *\n     * @method editVersion\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to Jira.\n     * @param {string} opts.versionId The id of the version to edit.\n     * @param {Object} opts.version See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3619}\n     * @param [callback] Called when the version has been modified.\n     * @return {Promise} Resolved when the version has been modified.\n     */\n    this.editVersion = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'PUT', opts.version);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get a bean containing the number of fixed in and affected issues for the given version.\n     *\n     * @method getRelatedIssueCounts\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version for which to retrieve related issues.\n     * @param [callback] Called when the count has been retrieved.\n     * @return {Promise} Resolved when the count has been retrieved.\n     */\n    this.getRelatedIssueCounts = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/relatedIssueCounts', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the number of unresolved issues for the given version\n     *\n     * @method getUnresolvedIssueCount\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version for which to retrieve unresolved issues.\n     * @param [callback] Called when the count has been retrieved.\n     * @return {Promise} Resolved when the count has been retrieved.\n     */\n    this.getUnresolvedIssueCount = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/unresolvedIssueCount', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the remote version links associated with the given version id.\n     *\n     * @method getRemoteLinks\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version for which to retrieve remote links.\n     * @param [callback] Called when the links have been retrieved.\n     * @return {Promise} Resolved when the links have been retrieved.\n     */\n    this.getRemoteLinks = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Create a remote version link via POST. The link's global id will be taken from the JSON payload if provided;\n     * otherwise, it will be generated.\n     *\n     * @method createRemoteLink\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version for which to retrieve unresolved issues.\n     * @param opts.remoteLink See {@link https://docs.atlassian.com/jira/REST/latest/#d2e3753}\n     * @param [callback] Called when the remote link has been created.\n     * @return {Promise} Resolved when the remote link has been created.\n     */\n    this.createRemoteLink = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink', 'POST', opts.remoteLink);\n        return this.jiraClient.makeRequest(options, callback, 'Remotelink Created');\n    };\n\n    /**\n     * Get a REST sub-resource representing a remote version link.\n     *\n     * @method getRemoteLinks\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version for which to retrieve the remote link\n     * @param opts.remoteLinkId The global id of the remote link\n     * @param [callback] Called when the link has been retrieved.\n     * @return {Promise} Resolved when the link has been retrieved.\n     */\n    this.getRemoteLink = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.remoteLinkId, 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete a remote version link.\n     *\n     * @method deleteRemoteLink\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.versionId The version id\n     * @param opts.remoteLinkId The global id of the remote link\n     * @param [callback] Called when the link has been deleted.\n     * @return {Promise} Resolved when the link has been deleted.\n     */\n    this.deleteRemoteLink = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink/' + opts.remoteLinkId, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Remote Link Deleted');\n    };\n\n    /**\n     * Delete a project version.\n     *\n     * @method deleteVersion\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string|number} opts.versionId The id of the version to delete.\n     * @param [callback] Called when the version is deleted.\n     * @return {Promise} Resolved when the version is deleted.\n     */\n    this.deleteVersion = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Version Deleted');\n    };\n\n    /**\n     * Delete all remote version links for a given version id.\n     *\n     * @method deleteAllRemoteLinks\n     * @memberOf VersionClient#\n     * @param {Object} opts The request options sent to the Jira API.\n     * @param {string|number} opts.versionId The id of the version to delete.\n     * @param [callback] Called when the version is deleted.\n     * @return {Promise} Resolved when the version is deleted.\n     */\n    this.deleteAllRemoteLinks = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/remotelink', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Remote Links Deleted');\n    };\n\n    /**\n     * Returns the remote version links for a given global id.\n     *\n     * @method getGlobalRemoteLink\n     * @memberOf VersionClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.globalId The global id of the remote resource that is linked to the versions\n     * @param [callback] Called when the remote link is returned.\n     * @return {Promise} Resolved when the remote link is returned.\n     */\n    this.getGlobalRemoteLink = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/version/remotelink'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {globalId: opts.globalId}\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf FilterClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {number} opts.versionId The id of the screen to use in the path.\n     * @param {Array} [opts.fields] The fields to include\n     * @param {Array} [opts.expand] The fields to expand\n     * @param {string} path The path of the endpoint following /version/{id}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        var basePath = '/version/' + opts.versionId;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n            qs.fields = qs.fields.slice(0, -1);\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n            qs.expand = qs.expand.slice(0, -1);\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/webhook.js":"\"use strict\";\n\nmodule.exports = WebhookClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/webhook/1.0/webhook'\n *\n * @param {JiraClient} jiraClient\n * @constructor WebhookClient\n */\nfunction WebhookClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns a list of all registered webhooks.\n     *\n     * @method getAllWebhooks\n     * @memberOf WebhookClient#\n     * @param opts Ignored\n     * @param [callback] Called when the webhooks have been retrieved.\n     * @return {Promise} Resolved when the webhooks have been retrieved.\n     */\n    this.getAllWebhooks = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildWebhookURL('/webhook'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns a webhook with a specific ID.\n     *\n     * @method getWebhook\n     * @memberOf WebhookClient#\n     * @param opts The options sent to the JIRA API.\n     * @param opts.webhookId The numerical webhook ID.\n     * @param [callback] Called when the webhook has been retrieved.\n     * @return {Promise} Resolved when the webhook has been retrieved.\n     */\n    this.getWebhook = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildWebhookURL('/webhook/' + opts.webhookId),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Registers a new webhook.\n     *\n     * @method createWebhook\n     * @memberOf WebhookClient#\n     * @param opts The options sent to the JIRA API.\n     * @param opts.name The name of the webhook.\n     * @param opts.url The URL of the webhook.\n     * @param opts.events An array of events with which the webhook should be registered. See\n     *   {@link https://developer.atlassian.com/jiradev/jira-apis/webhooks#Webhooks-configureConfiguringawebhook}.\n     * @param opts.enabled Whether the webhook is enabled.\n     * @param opts.filter An object containing filter configuration.\n     * @param opts.filter.issue-related-events-section A filter for issues, written in JQL.\n     * @param opts.excludeBody Whether to send an empty body to the webhook URL.\n     * @param [callback] Called when the webhook has been retrieved.\n     * @return {Promise} Resolved when the webhook has been retrieved.\n     */\n    this.createWebhook = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildWebhookURL('/webhook'),\n            method: 'POST',\n            json: true,\n            body: opts,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Deletes a registered webhook.\n     *\n     * @method deleteWebhook\n     * @memberOf WebhookClient#\n     * @param opts The options sent to the JIRA API.\n     * @param opts.webhookId The numerical webhook ID.\n     * @param [callback] Called when the webhook has been retrieved.\n     * @return {Promise} Resolved when the webhook has been retrieved.\n     */\n    this.deleteWebhook = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildWebhookURL('/webhook/' + opts.webhookId),\n            method: 'DELETE',\n            json: true,\n            followAllRedirects: true\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/workflow.js":"\"use strict\";\n\nmodule.exports = WorkflowClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/workflow'\n *\n * @param {JiraClient} jiraClient\n * @constructor WorkflowClient\n */\nfunction WorkflowClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns all workflows.\n     *\n     * @method getWorkflows\n     * @memberOf WorkflowClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {string} [opts.workflowName] The name of the workflow to retrieve.\n     * @param [callback] Called when the workflow(s) have been retrieved.\n     * @return {Promise} Resolved when the workflow(s) have been retrieved.\n     */\n    this.getWorkflows = function (opts, callback) {\n        var qs = {};\n        if (opts && typeof opts === 'object' && opts.hasOwnProperty('workflowName')) {\n            qs.workflowName = opts.workflowName;\n        }\n        var options = {\n            uri: this.jiraClient.buildURL('/workflow'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: qs\n        };\n\n        return this.jiraClient.makeRequest(options, callback);\n    };\n}\n","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/workflowScheme.js":"\"use strict\";\n\nmodule.exports = WorkflowSchemeClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/workflowscheme'\n * @param {JiraClient} jiraClient\n * @constructor WorkflowSchemeClient\n */\nfunction WorkflowSchemeClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Create a new workflow scheme. The body contains a representation of the new scheme. Values not passed are\n     * assumed to be set to their defaults.\n     *\n     * @method createWorkflowScheme\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowScheme See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2196}\n     * @param [callback] Called when the workflow scheme has been created.\n     * @return {Promise} Resolved when the workflow scheme has been created.\n     */\n    this.createWorkflowScheme = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/workflowscheme'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: opts.workflowScheme\n        };\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Update the passed workflow scheme. The body of the request is a representation of the workflow scheme. Values\n     * not passed are assumed to indicate no change for that field. The passed representation can have its\n     * updateDraftIfNeeded flag set to true to indicate that the draft should be created and/or updated when the actual\n     * scheme cannot be edited (e.g. when the scheme is being used by a project). Values not appearing the body will\n     * not be touched.\n     *\n     * @method editWorkflowScheme\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.workflowScheme See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2305}\n     * @param [callback] Called when the workflow scheme has been edited.\n     * @return {Promise} Resolved when the workflow scheme has been edited.\n     */\n    this.editWorkflowScheme = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'PUT', opts.workflowScheme);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the requested workflow scheme\n     *\n     * @method getWorkflowScheme\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [opts.returnDraftIfExists=false] when true indicates that a scheme's draft, if it exists, should be\n     *     queried instead of the scheme itself.\n     * @param [callback] Called when the workflow scheme has been retrieved.\n     * @return {Promise} Resolved when the workflow scheme has been retrieved.\n     */\n    this.getWorkflowScheme = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'GET', null, {returnDraftIfExists: opts.returnDraftIfExists});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete the passed workflow scheme.\n     *\n     * @method deleteWorkflowScheme\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the workflow scheme has been deleted.\n     * @return {Promise} Resolved when the workflow scheme has been deleted.\n     */\n    this.deleteWorkflowScheme = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback, 'Workflow Scheme Deleted');\n    };\n\n    /**\n     * Create a draft for the passed scheme. The draft will be a copy of the state of the parent.\n     *\n     * @method createDraft\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the draft has been created.\n     * @return {Promise} Resolved when the draft has been created.\n     */\n    this.createDraft = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/createdraft', 'POST');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the default workflow from the passed workflow scheme.\n     *\n     * @method getDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.returnDraftIfExists when true indicates that a scheme's draft, if it exists, should be queried\n     *     instead of the scheme itself.\n     * @param [callback] Called when the default workflow is returned.\n     * @return {Promise} Resolved when the default workflow is returned.\n     */\n    this.getDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/default', 'GET', null, {returnDraftIfExists: opts.returnDraftIfExists});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the default workflow from the passed workflow scheme.\n     *\n     * @method removeDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be\n     *     edited (e.g. when it is being used by a project).\n     * @param [callback] Called when the defaul workflow has been removed.\n     * @return {Promise} Resolved when the defaul workflow has been removed.\n     */\n    this.removeDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/default', 'DELETE', null, {updateDraftIfNeeded: opts.updateDraftIfNeeded});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the default workflow from the passed workflow scheme.\n     *\n     * @method setDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.workflowName The name of the new deafault workflow\n     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be\n     *     edited (e.g. when it is being used by a project).\n     * @param [callback] Called when the default workflow has been updated.\n     * @return {Promise} Resolved when the default workflow has been updated.\n     */\n    this.setDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/default', 'PUT', {\n            workflow: opts.workflowName,\n            updateDraftIfNeeded: opts.updateDraftIfNeeded\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the requested draft workflow scheme\n     *\n     * @method getDraft\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the draft has been retrieved.\n     * @return {Promise} Resolved when the draft has been retrieved.\n     */\n    this.getDraft = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Update a draft workflow scheme. The draft will created if necessary. The body is a representation of the\n     * workflow scheme. Values not passed are assumed to indicate no change for that field.\n     *\n     * @method editDraft\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.draft See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2575}\n     * @param [callback] Called when the draft has been edited.\n     * @return {Promise} Resolved when the draft has been edited.\n     */\n    this.editDraft = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft', 'PUT', opts.draft);\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete the passed draft workflow scheme.\n     *\n     * @method deleteDraft\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the draft has been deleted.\n     * @return {Promise} Resolved when the draft has been deleted.\n     */\n    this.deleteDraft = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Get the default workflow from the passed draft workflow scheme\n     *\n     * @method getDraftDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the default workflow is returned.\n     * @return {Promise} Resolved when the default workflow is returned.\n     */\n    this.getDraftDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/default', 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the default workflow from the passed workflow scheme.\n     *\n     * @method setDraftDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.workflowName The name of the new default workflow\n     * @param [callback] Called when the default workflow has been updated.\n     * @return {Promise} Resolved when the default workflow has been updated.\n     */\n    this.setDraftDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/default', 'PUT', {\n            workflow: opts.workflowName,\n            updateDraftIfNeeded: opts.updateDraftIfNeeded\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the default workflow from the passed draft workflow scheme.\n     *\n     * @method removeDraftDefaultWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param [callback] Called when the defaul workflow has been removed.\n     * @return {Promise} Resolved when the defaul workflow has been removed.\n     */\n    this.removeDraftDefaultWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/default', 'DELETE');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the issue type mapping for the passed workflow scheme.\n     *\n     * @method getIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param opts.returnDraftIfExists when true indicates that a scheme's draft, if it exists, should be queried\n     *     instead of the scheme itself.\n     * @param [callback] Called when the issue type has been retrieved.\n     * @return {Promise} Resolved when the issue type has been retrieved.\n     */\n    this.getIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'GET', null,\n            {returnDraftIfExists: opts.returnDraftIfExists});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Set the issue type mapping for the passed scheme. The passed representation can have its updateDraftIfNeeded\n     * flag set to true to indicate that the draft should be created/updated when the actual scheme cannot be edited.\n     *\n     * @method editIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param opts.workflow The new workflow\n     * @param opts.updateDraftIfNeeded when true will create and return a draft when the workflow scheme cannot be\n     *     edited (e.g. when it is being used by a project).\n     * @param [callback] Called when the issue type has been edited\n     * @return {Promise} Resolved when the issue type has been edited\n     */\n    this.editIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'PUT', {\n            workflow: opts.workflow,\n            updateDraftIfNeeded: opts.updateDraftIfNeeded\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the specified issue type mapping from the scheme.\n     *\n     * @method removeIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param [callback] Called when the issue type mapping has been removed.\n     * @return {Promise} Resolved when the issue type mapping has been removed.\n     */\n    this.removeIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/issuetype/' + opts.issueType, 'DELETE', null, {\n            updateDraftIfNeeded: opts.updateDraftIfNeeded\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the issue type mapping for the passed draft workflow scheme.\n     *\n     * @method getDraftIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API.\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param [callback] Called when the issue type has been retrieved.\n     * @return {Promise} Resolved when the issue type has been retrieved.\n     */\n    this.getDraftIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'GET');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Set the issue type mapping for the passed draft scheme.\n     *\n     * @method editDraftIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param opts.workflow The new workflow\n     * @param [callback] Called when the issue type has been edited\n     * @return {Promise} Resolved when the issue type has been edited\n     */\n    this.editDraftIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'PUT', {workflow: opts.workflow});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Remove the specified issue type mapping from the scheme.\n     *\n     * @method removeDraftIssueType\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.issueType The issue type\n     * @param [callback] Called when the issue type mapping has been removed.\n     * @return {Promise} Resolved when the issue type mapping has been removed.\n     */\n    this.removeDraftIssueType = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/issuetype/' + opts.issueType, 'DELETE');\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the workflow mappings or requested mapping to the caller for the passed scheme.\n     *\n     * @method getWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.workflowName The name of the workflow.\n     * @param [callback] Called when the workflow has been retrieved.\n     * @return {Promise} Resolved when the workflow has been retrieved.\n     */\n    this.getWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/workflow', 'GET', null, {\n            workflowName: opts.workflowName\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Returns the workflow mappings or requested mapping to the caller for the passed draft scheme.\n     *\n     * @method getDraftWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param opts The request options sent to the Jira API\n     * @param opts.workflowSchemeId The id of the workflow scheme.\n     * @param opts.workflowName The name of the workflow.\n     * @param [callback] Called when the workflow has been retrieved.\n     * @return {Promise} Resolved when the workflow has been retrieved.\n     */\n    this.getDraftWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/workflow', 'GET', null, {\n            workflowName: opts.workflowName\n        });\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Update the scheme to include the passed mapping. The body is a representation of the workflow mapping. Values\n     * not passed are assumed to indicate no change for that field.\n     *\n     * @method editWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.workflowSchemeId The id of the workflow scheme.\n     * @param {string} opts.workflowName The name of the workflow.\n     * @param {Array} opts.issueTypes The new issue types to inclue in the workflow.\n     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2509}\n     * @param [callback] Called when the workflow has been edited.\n     * @return {Promise} Resolved when the workflow has been edited.\n     */\n    this.editWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/workflow', 'PUT', {\n            workflow: opts.workflowName,\n            issueTypes: opts.issueTypes\n        }, {workflowName: opts.workflowName});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Update the draft scheme to include the passed mapping. The body is a representation of the workflow mapping.\n     * Values not passed are assumed to indicate no change for that field.\n     *\n     * @method editDraftWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.workflowSchemeId The id of the workflow scheme.\n     * @param {string} opts.workflowName The name of the workflow.\n     * @param {Array} opts.issueTypes The new issue types to inclue in the workflow.\n     *      See {@link https://docs.atlassian.com/jira/REST/latest/#d2e2670 }\n     * @param [callback] Called when the workflow has been edited.\n     * @return {Promise} Resolved when the workflow has been edited.\n     */\n    this.editDraftWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/workflow', 'PUT', {\n            workflow: opts.workflowName,\n            issueTypes: opts.issueTypes\n        }, {workflowName: opts.workflowName});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete the passed workflow from the workflow scheme.\n     *\n     * @method deleteWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.workflowSchemeId The id of the workflow scheme.\n     * @param {string} opts.workflowName The name of the workflow.\n     * @param [callback] Called when the workflow has been edited.\n     * @return {Promise} Resolved when the workflow has been edited.\n     */\n    this.deleteWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/workflow', 'DELETE', null, {workflowName: opts.workflowName});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Delete the passed workflow from the workflow draft scheme.\n     *\n     * @method deleteDraftWorkflow\n     * @memberOf WorkflowSchemeClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.workflowSchemeId The id of the workflow scheme.\n     * @param {string} opts.workflowName The name of the workflow.\n     * @param [callback] Called when the workflow has been edited.\n     * @return {Promise} Resolved when the workflow has been edited.\n     */\n    this.deleteDraftWorkflow = function (opts, callback) {\n        var options = this.buildRequestOptions(opts, '/draft/workflow', 'DELETE', null, {workflowName: opts.workflowName});\n        return this.jiraClient.makeRequest(options, callback);\n    };\n\n    /**\n     * Build out the request options necessary to make a particular API call.\n     *\n     * @private\n     * @method buildRequestOptions\n     * @memberOf WorkflowSchemeClient#\n     * @param {Object} opts The arguments passed to the method.\n     * @param {number} opts.workflowSchemeId The id of the workflowScheme to use in the path.\n     * @param {Array} [opts.fields] The fields to include\n     * @param {Array} [opts.expand] The fields to expand\n     * @param {string} path The path of the endpoint following /workflowScheme/{id}\n     * @param {string} method The request method.\n     * @param {Object} [body] The request body, if any.\n     * @param {Object} [qs] The querystring, if any.  opts.expand and opts.fields arrays will be automagically added.\n     * @returns {{uri: string, method: string, body: Object, qs: Object, followAllRedirects: boolean, json: boolean}}\n     */\n    this.buildRequestOptions = function (opts, path, method, body, qs) {\n        var basePath = '/workflowscheme/' + opts.workflowSchemeId;\n        if (!qs) qs = {};\n        if (!body) body = {};\n\n        if (opts.fields) {\n            qs.fields = '';\n            opts.fields.forEach(function (field) {\n                qs.fields += field + ','\n            });\n            qs.fields = qs.fields.slice(0, -1);\n        }\n\n        if (opts.expand) {\n            qs.expand = '';\n            opts.expand.forEach(function (ex) {\n                qs.expand += ex + ','\n            });\n            qs.expand = qs.expand.slice(0, -1);\n        }\n\n        return {\n            uri: this.jiraClient.buildURL(basePath + path),\n            method: method,\n            body: body,\n            qs: qs,\n            followAllRedirects: true,\n            json: true\n        };\n    };\n}","/home/travis/build/npmtest/node-npmtest-jira-connector/node_modules/jira-connector/api/worklog.js":"\"use strict\";\n\nmodule.exports = WorklogClient;\n\n/**\n * Used to access Jira REST endpoints in '/rest/api/2/worklog'\n *\n * @param {JiraClient} jiraClient\n * @constructor WorkLogClient\n */\nfunction WorklogClient(jiraClient) {\n    this.jiraClient = jiraClient;\n\n    /**\n     * Returns worklogs id and delete time of worklogs that were deleted since given time. The returns set of worklogs is \n     * limited to 1000 elements. This API will not return worklogs deleted during last minute.\n     *\n     * @method getWorklogDeleted\n     * @memberOf WorklogClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.since A date time in unix timestamp format since when deleted worklogs will be returned.\n     *      Default: 0\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */ \n    this.getWorklogDeleted = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/worklog/deleted'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                since: opts.since\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback)\n    };\n\n    /**\n     * Returns Returns worklogs for given worklog ids. Only worklogs to which the calling user has permissions, \n     * will be included in the result. The returns set of worklogs is limited to 1000 elements.\n     *\n     * @method worklogList\n     * @memberOf WorklogClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {array} [opts.ids] a JSON array named ids which contains a list of issue IDs\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */ \n    this.worklogList = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/worklog/list'),\n            method: 'POST',\n            json: true,\n            followAllRedirects: true,\n            body: {\n                ids: opts.ids\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback)\n    };\n\n    /**\n     * Returns worklogs id and update time of worklogs that were updated since given time. The returns set of worklogs is \n     * limited to 1000 elements. This API will not return worklogs deleted during last minute.\n     *\n     * @method getWorklogDeleted\n     * @memberOf WorklogClient#\n     * @param {Object} opts The request options sent to the Jira API\n     * @param {number} opts.since A date time in unix timestamp format since when updated worklogs will be returned.\n     *      Default: 0\n     * @param [callback] Called when the search results are retrieved.\n     * @return {Promise} Resolved when the search results are retrieved.\n     */ \n    this.getWorklogUpdated = function (opts, callback) {\n        var options = {\n            uri: this.jiraClient.buildURL('/worklog/updated'),\n            method: 'GET',\n            json: true,\n            followAllRedirects: true,\n            qs: {\n                since: opts.since\n            }\n        };\n        return this.jiraClient.makeRequest(options, callback)\n    }\n}\n"}